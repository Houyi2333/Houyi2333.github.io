<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你不定积分没加C的博客</title>
  
  <subtitle>除了不定积分，还有微分方程通解需要+C</subtitle>
  <link href="https://houyi2333.github.io/atom.xml" rel="self"/>
  
  <link href="https://houyi2333.github.io/"/>
  <updated>2024-01-27T11:18:34.575Z</updated>
  <id>https://houyi2333.github.io/</id>
  
  <author>
    <name>你不定积分没加C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 开发入门</title>
    <link href="https://houyi2333.github.io/2024/01/22/14-50-06/"/>
    <id>https://houyi2333.github.io/2024/01/22/14-50-06/</id>
    <published>2024-01-22T06:50:06.000Z</published>
    <updated>2024-01-27T11:18:34.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-React-？"><a href="#什么是-React-？" class="headerlink" title="什么是 React ？"></a>什么是 React ？</h2><p>在2024年的今天，我们的浏览器仍然采用最基本的 html + CSS + JavaScript 构建页面，但是我们可以很明显的感觉到，编写原生三件套代码是比较复杂的。并且在 Web 项目规模庞大和设备多样性越发丰富的今天，代码的可维护性、开发效率、跨平台开发、性能等因素都会影响到我们对开发工具的选择。因此人们想到了一种方式，可不可以先编写一些简化的、高效率的代码，然后用他们生成 html + CSS + JavaScript 并运行在浏览器上。就像是我们不必编写汇编语言，写 C语言 即可构建可执行文件。就这样， React 诞生了</p><p>维基百科这样定义 React ：React 是一个前端 JavaScript 工具<strong>库</strong>，用于基于 UI 组件构建用户界面</p><p>当前常用的工具（库或框架）不止有 React ，比如 Vue、Angular 等都是常见的构建前端页面的工具</p><p>MDN 这样描述 React ：React 不是一个框架——它的应用甚至不局限于 Web 开发，它可以与其他库一起使用以渲染到特定环境。例如， React Native 可用于构建移动应用程序； React 360 可用于构建虚拟现实应用程序……</p><p>React 是一门令人惊叹的前端技术，其创新性的设计理念和强大的功能使其成为现代 Web 开发的领军者。通过引入虚拟 DOM 、组件化开发和单向数据流等概念， React 不仅提高了应用的性能和可维护性，还让开发者在构建复杂用户界面时拥有更高的灵活性和控制力。 JSX 语法的引入使 UI 代码更加直观和易读，而庞大而活跃的社区生态系统则为开发者提供了丰富的工具和支持。同时， React 的跨平台特性使其在移动开发领域也大放异彩，成为 React Native 的基石。 React 可以被视为一个跨时代的前端开发工具和框架。其引入了许多创新性的概念和技术，对前端开发的方式和效率产生了深远的影响</p><span id="more"></span><h2 id="React-的前世今生"><a href="#React-的前世今生" class="headerlink" title="React 的前世今生"></a>React 的前世今生</h2><h4 id="诞生背景："><a href="#诞生背景：" class="headerlink" title="诞生背景："></a>诞生背景：</h4><p>React 由 Facebook 的工程师 Jordan Walke 于 2011 年创建。最初的目标是解决 Facebook 内部复杂应用的性能问题和开发效率问题</p><h4 id="开源发布："><a href="#开源发布：" class="headerlink" title="开源发布："></a>开源发布：</h4><p>React 在 2013 年 5 月正式开源发布。这一举动使得更多的开发者能够使用和贡献 React ，促进了它的快速发展</p><h4 id="组件化开发："><a href="#组件化开发：" class="headerlink" title="组件化开发："></a>组件化开发：</h4><p>React采用了<strong>组件化</strong>的开发方式，将 UI 拆分为独立的<strong>组件</strong>，使得代码更加<strong>模块化</strong>、可维护。组件化开发成为React的<strong>核心理念</strong>之一，也被其他框架和库广泛采用</p><h4 id="JSX-语法："><a href="#JSX-语法：" class="headerlink" title="JSX 语法："></a>JSX 语法：</h4><p>React 引入了 JSX 语法，允许在 JavaScript 中编写类似 XML 的标记，使 UI 的描述更加直观。 JSX 在编译时会被转换为普通的 JavaScript 代码，使开发者的代码编写更为便捷</p><h4 id="React-Native："><a href="#React-Native：" class="headerlink" title="React Native："></a>React Native：</h4><p>随着移动端应用的兴起， React 的影响力扩展到了<strong>移动开发</strong>领域。 React Native 使开发者能够使用 React 的思想和组件化开发方式来构建原生移动应用，实现了跨平台的目标</p><h4 id="持续更新："><a href="#持续更新：" class="headerlink" title="持续更新："></a>持续更新：</h4><p>React团队持续进行版本迭代和改进，引入新的特性和优化，以适应前端技术的不断发展和用户需求的变化</p><hr><p>（上面随便看看就行，下面才是正文）</p><h2 id="React-，启动！"><a href="#React-，启动！" class="headerlink" title="React ，启动！"></a>React ，启动！</h2><p>在某个你想要建立该项目的目录下，运行 React 官方提供的脚手架：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create react-app learn-react --template typescript -y</span><br></pre></td></tr></table></figure><p>这行命令表示在当前目录下创建一个新的 react 项目，项目名称为 learn-react ，使用 TypeScript 而不是 JavaScript</p><p>如果安装顺利，使用命令 <code>cd learn-react</code> 进入项目文件夹，输入 <code>npm start</code> 即可编译整个应用，随后应当就可以通过本地 3000 端口访问到 React 的欢迎界面了</p><p><img src="/2024/01/22/14-50-06/image-20240122153740520.png" alt="image-20240122153740520"></p><p>为了更好地阅读本文档，推荐下载简化版 React 框架。其中仅保留了最基础、最必要的代码文件</p><p>下载简化版框架之前，我们希望你已经通过上述步骤成功初始化了一个新的 React 应用并能够在 3000 端口访问到欢迎界面。如果已经确认初始化成功，可以通过 <a href="./src.zip">该链接</a> 下载压缩包，请在解压后使用压缩包内的 <code>src</code> 文件夹替换你的 React 应用的 <code>src</code> 文件夹，并再次使用 <code>npm start</code>  命令运行 React 应用</p><p>如果你现在能够在 3000 端口访问到一个写有 <code>Hello, React!</code> 字样的页面，则已经完成了配置</p><p><img src="/2024/01/22/14-50-06/image-20240122155632922.png" alt="image-20240122155632922"></p><h2 id="React-项目的结构"><a href="#React-项目的结构" class="headerlink" title="React 项目的结构"></a>React 项目的结构</h2><p><img src="/2024/01/22/14-50-06/image-20240122171355674.png" alt="image-20240122171355674"></p><h4 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h4><p>存放项目依赖的第三方库和工具</p><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>包含不需要 webpack 处理的静态资源，如 HTML 文件、网页图标（favicon）等。其中 <code>index.html</code> 是主 HTML 文件，是 React 项目页面加载的入口文件，后面还会再提到它</p><h4 id="src"><a href="#src" class="headerlink" title="src"></a>src</h4><p>包含 React 项目的源码，我们主要编写的就是这个文件夹的内容</p><p>通常里面还会包含 <code>components</code> 、 <code>pages</code> 、 <code>styles</code> 三个文件夹，分别存放了可复用的 React 组件、页面级的 React 组件、样式文件</p><p><code>App.tsx</code> 是我们自定义的一个组件，通过 <code>export default App;</code> 导出，可以被其他文件引入</p><p>接下来重点讲 和 <code>index.tsx</code></p><h5 id="index-tsx"><a href="#index-tsx" class="headerlink" title="index.tsx"></a>index.tsx</h5><p><code>index.tsx</code> 是一个 React 项目中的入口文件，通常用于渲染主应用组件到 HTML 页面：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.tsx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span>);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>解释一下这个文件实现的功能</p><p>使用 <code>import</code> 语句导入 React 和 ReactDOM 库，用于创建和渲染 React 组件</p><p>使用 <code>import</code> 导入主应用组件 <code>App</code> </p><p>使用 <code>ReactDOM.createRoot</code> 方法创建一个 <code>root</code> 对象。这个对象代表了 React 渲染的根节点，对应于页面上的容器元素。再通过 <code>document.getElementById(&#39;root&#39;)</code> 方法获取到页面的根元素，之后使用 <code>root.render</code> 方法渲染主应用组件 <code>&lt;App /&gt;</code> 到根节点</p><p>实例化一个组件也是简单的，类似 HTML 语法，只要像 <code>&lt;App /&gt;</code> 一样用尖括号把组件名包裹起来就可以了</p><p>那我们 id 为 <code>root</code> 的根节点在哪里呢？我们打开 <code>public</code> 中的 <code>index.html</code>：</p><p><img src="/2024/01/22/14-50-06/image-20240122173348696.png" alt="image-20240122173348696"></p><p>诶！根节点就在 <code>index.html</code>。而 React 项目页面加载的入口文件就是 <code>index.html</code> ，这也就解释了为什么页面中可以呈现出我们 <code>return</code> 的 <code>h1</code></p><p><code>index.tsx</code> 的作用就是搭建起传统 HTML 和 React TSX 之间的桥梁，让我们可以自由地使用 TSX 语法编写组件，而将这些组件转换到 HTML 的任务则交给了 React 框架</p><p>那又一个问题出现了： React 项目的 <code>public</code> 文件夹里的 <code>index.html</code> 并没有 link 到 <code>src</code> 下的 <code>index.tsx</code> ，那 <code>index.tsx</code> 是怎么 get 到 <code>root</code> 这个 <code>id</code> 的呢？</p><p>这是因为 React DOM 在运行时会自动查找页面上具有特定 <code>id</code> 的元素，然后将组件渲染到该元素中。具体来说，React DOM 通常会在 <code>index.html</code> 中的 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 元素处渲染应用。这个元素是在 <code>index.html</code> 中静态存在的，而不是通过 JavaScript 动态创建的。React 会将应用渲染到这个预定义的根元素上。说白了就是，这套逻辑已经在 React 的原码里写死了</p><h4 id="gitgnore"><a href="#gitgnore" class="headerlink" title=".gitgnore"></a>.gitgnore</h4><p>指定 Git 版本控制系统忽略特定文件或目录的配置文件，很熟悉了，不多介绍</p><h4 id="prettierrc"><a href="#prettierrc" class="headerlink" title=".prettierrc"></a>.prettierrc</h4><p>用于配置 Prettier 工具的文件（这不是 React 项目之一，这只是 Prettier 插件的配置文件，是我自己添加的）</p><h4 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title=".package-lock.json"></a>.package-lock.json</h4><p><code>npm</code> 在安装包时生成的一个锁定文件，规定了包的安装版本，防止在不同的开发环境上因包的版本不一致出现问题</p><h4 id="package-json"><a href="#package-json" class="headerlink" title=".package.json"></a>.package.json</h4><p>在上一篇《现代前端开发基础》已经讲过</p><h4 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h4><p>React 官方写的 README</p><h2 id="JSX-和-JS-的区别"><a href="#JSX-和-JS-的区别" class="headerlink" title="JSX 和 JS 的区别"></a>JSX 和 JS 的区别</h2><p>JSX 是一种 JavaScript 的语法扩展，也可以说 JSX 是一种方便构建 UI 的语法糖，用于在 JavaScript 代码中描述 UI 结构</p><p>JSX 和原生 JavaScript 的最大差别就是引入了标签语法：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>这类似于 HTML 标签的语法定义了一个对象，其等价于以下表达：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;p&quot;</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>既然标签可以是变量，那它就可以被返回：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p><code>React.FC</code> 是 React 中的一个泛型类型，用于定义函数组件（Function Components）。在使用 TypeScript 编写 React 组件时，可以使用 <code>React.FC</code> 来明确函数组件的类型<br>我们注意 <code>return &lt;h1&gt;Hello, React!&lt;/h1&gt;;</code> 这行代码，它使得 <code>App</code> 这个函数返回了一个 <code>h1</code> 标签，这种写法我们称为<strong>声明式 UI </strong></p><p>在 JSX 中，每个 JSX 表达式必须被包裹在一个父元素中。比如这样的代码就会报错：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, JSX!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>这是因为 JSX 实际上被转译成 JavaScript 代码，而 JavaScript 中每个表达式只能有一个根节点。</p><p>如果真的要返回两个 <code>h1</code> ，可以考虑将他们放在一个 <code>div</code> 中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, JSX!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>如果你不想使用额外的容器元素，你可以考虑使用 React Fragments。React Fragments（片段）是一种特殊的 React 组件，用于在不添加额外 DOM 元素的情况下包裹多个子元素。Fragments 提供了一种解决“JSX 表达式必须具有一个父元素”这一限制的方式。</p><p>使用 React Fragments 的语法可以是空标签 <code>&lt;&gt;&lt;/&gt;</code> 或 <code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> ，通常使用空标签</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, JSX!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>下一篇博客我们将会讲解 React 的核心概念——组件。在React中，组件是构建用户界面的基本单元，具有独立的状态和行为，能够将复杂的UI拆分为可管理的、可复用的模块。组件化开发使得代码结构更清晰、可维护性更强，同时提供了一种高效的方式来组织、测试和重用代码。通过组件，React支持了声明式 UI 的开发范式，使开发者能够专注于描述界面的外观和行为，而无需过多关注底层DOM操作，从而提高开发效率。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-React-？&quot;&gt;&lt;a href=&quot;#什么是-React-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 React ？&quot;&gt;&lt;/a&gt;什么是 React ？&lt;/h2&gt;&lt;p&gt;在2024年的今天，我们的浏览器仍然采用最基本的 html + CSS + JavaScript 构建页面，但是我们可以很明显的感觉到，编写原生三件套代码是比较复杂的。并且在 Web 项目规模庞大和设备多样性越发丰富的今天，代码的可维护性、开发效率、跨平台开发、性能等因素都会影响到我们对开发工具的选择。因此人们想到了一种方式，可不可以先编写一些简化的、高效率的代码，然后用他们生成 html + CSS + JavaScript 并运行在浏览器上。就像是我们不必编写汇编语言，写 C语言 即可构建可执行文件。就这样， React 诞生了&lt;/p&gt;
&lt;p&gt;维基百科这样定义 React ：React 是一个前端 JavaScript 工具&lt;strong&gt;库&lt;/strong&gt;，用于基于 UI 组件构建用户界面&lt;/p&gt;
&lt;p&gt;当前常用的工具（库或框架）不止有 React ，比如 Vue、Angular 等都是常见的构建前端页面的工具&lt;/p&gt;
&lt;p&gt;MDN 这样描述 React ：React 不是一个框架——它的应用甚至不局限于 Web 开发，它可以与其他库一起使用以渲染到特定环境。例如， React Native 可用于构建移动应用程序； React 360 可用于构建虚拟现实应用程序……&lt;/p&gt;
&lt;p&gt;React 是一门令人惊叹的前端技术，其创新性的设计理念和强大的功能使其成为现代 Web 开发的领军者。通过引入虚拟 DOM 、组件化开发和单向数据流等概念， React 不仅提高了应用的性能和可维护性，还让开发者在构建复杂用户界面时拥有更高的灵活性和控制力。 JSX 语法的引入使 UI 代码更加直观和易读，而庞大而活跃的社区生态系统则为开发者提供了丰富的工具和支持。同时， React 的跨平台特性使其在移动开发领域也大放异彩，成为 React Native 的基石。 React 可以被视为一个跨时代的前端开发工具和框架。其引入了许多创新性的概念和技术，对前端开发的方式和效率产生了深远的影响&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>从 JavaScript 到 TypeScript</title>
    <link href="https://houyi2333.github.io/2024/01/21/17-16-23/"/>
    <id>https://houyi2333.github.io/2024/01/21/17-16-23/</id>
    <published>2024-01-21T09:16:23.000Z</published>
    <updated>2024-01-22T06:22:46.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是TypeScript？"><a href="#什么是TypeScript？" class="headerlink" title="什么是TypeScript？"></a>什么是TypeScript？</h2><p>简而言之，TypeScript 是 JavaScript 的超集，它继承了 JavaScript 所有的语法，并且可以编译为纯 JavaScript 。它的目的并不是创造一种全新语言，而是增强 JavaScript 的功能，使其更适合多人合作的企业级项目。</p><p>既然是超集，那么它<strong>超</strong>在哪里呢？</p><p>我们知道， JavaScript 的变量是没有类型的，无论用 <code>var, let, const</code> 哪一个关键字，都无法指定变量的类型，因此我们称 JS 是一个“弱类型”的语言。例如下面的代码，在 JavaScript 中是完全合法的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;34&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = a + str; <span class="comment">// res = &quot;134&quot;</span></span><br></pre></td></tr></table></figure><p>这对我们来说是非常不好的，是反直觉的，正常人的思维应该是，一个数字和字符串怎么可能可以相加呢？这应该报错！</p><p>TypeScript 最大的特点就是引入了类型系统，这样就可以在编译为 JavaScript 代码之前由编译器进行类型检查。在这样的条件下，TypeScript 中的变量在声明的时候就可以指定类型，编译器在将 TypeScript 代码编译为 JavaScript 代码的时候会进行类型检查，若有不符合类型声明的情况则会报错：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = (<span class="attr">name</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">2</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>上面的 <code>fun</code> 函数要求传入一个 <code>string</code> 类型的值，且返回类型为 <code>void</code> 但是我们调用的时候却传入了一个数字2，这显然是不符合函数参数要求的，因此 TypeScript 编译器会报错</p><p>TypeScript 有着静态类型检查，具有类型系统，可以在开发时捕获许多常见的错误。通过类型检查，可以在编码阶段就发现潜在的问题，减少运行时错误。因此我们更推荐使用 TypeScript 进行项目开发，而不是 JavaScript</p><span id="more"></span><h2 id="TypeScript，启动！"><a href="#TypeScript，启动！" class="headerlink" title="TypeScript，启动！"></a>TypeScript，启动！</h2><p> Node.js 提供了 npm 包管理器，通过<code>npm install -g typescript</code> 即可安装 TypeScript 。通过 <code>tsc</code> 命令即可将 TypeScript 代码编译为 JavaScript 代码。但是它并不支持直接运行编译后的代码，而 <code>ts-node</code> 正好填补了这一空缺，它封装了 TypeScript 的编译过程，使得 TypeScript 代码无需编译成 JavaScript，就能直接运行 TypeScript 代码。由于这是一个教学文档，本文先不使用 <code>ts-node</code></p><p>我们在一个文件夹下启动命令行，输入 <code>npm install -g typescript</code> 安装 TypeScript ，之后输入 <code>tsc --init</code>即可在当前文件夹下初始化 TypeScript 项目。我们会发现当前文件夹下多了一个 <code>tsconfig.json</code> 文件，这是 <code>TypeScript</code> 项目的配置文件，它包含了编译器的配置选项，我们暂时先不动它</p><p>在当前文件夹下新建 <code>index.ts</code> 文件，并编写：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;TypeScript&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;str&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure><p>之后在命令行输入 <code>tsc index.ts</code>，即可编译 <code>index.ts</code> ，同时编译生成的<code>index.js</code> 会被放在同一目录下</p><p>在命令行输入 <code>node index.js</code> ，如果成功输出了 <code>Hello, TypeScript!</code>，证明你的电脑已经成功安装 TypeScript 编译器</p><h2 id="TypeScript-的变量类型"><a href="#TypeScript-的变量类型" class="headerlink" title="TypeScript 的变量类型"></a>TypeScript 的变量类型</h2><p>TypeScript 的变量类型与C语言相比简单的多，仅有<strong>布尔类型( <em>boolean</em> )</strong>、<strong>数字类型( <em>number</em> )</strong>、<strong>字符串类型( <em>string</em> )</strong>、<strong>未定义类型( <em>undefined</em> )</strong>、<strong>空类型( <em>null</em> )</strong>、<strong>大数类型( <em>bigint</em> )</strong>、<strong>符号类型( <em>symbol</em> )</strong>、<strong>任意类型( <em>any</em> )</strong>、<strong>never类型( <em>never</em> )</strong></p><p>其中有必要细讲的是未定义与空，还有任意类型。大数和符号不常用，感兴趣可以自行Google</p><h4 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h4><p>未定义和空都表示空，但 <code>null</code> 表示这个元素存在，但是是空的； <code>undefined</code> 表示这个元素干脆就不存在。且 <code>undefined</code> 要比 <code>null</code> 常见的多</p><p>这两个类型的相同点是，他们都是只有一个值的数据类型， <code>undefined</code> 的值只有 <code>undefined</code> ， <code>null</code> 的值只有 <code>null</code></p><p>我们先看一张比较经典的图片，该图来自 stackoverflow 的回答</p><p><img src="/2024/01/21/17-16-23/T9M2J.png" alt="T9M2J"></p><ul><li>非零值就像一个装有卫生纸卷的支架，并且管子上仍然有纸巾。</li><li>零值就像一个带有空卫生纸管的支架。</li><li>空值就像一个没有卫生纸管的支架。</li><li>未定义就像连支架都没有</li></ul><p>对于一个未定义的变量，执行 <code>typeof</code> 操作符，那么就会返回 <code>undefined</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(data)); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(src)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里我们没有使用 <code>===</code> 来判断，因为对于尚未声明过的变量，我们只能执行使用typeof操作符检测其数据类型这个操作，使用其他的操作都会报错</p><p>还有使用对象中不存在的属性，也会返回 <code>undefined</code> ：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line"><span class="attr">prop</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">abcdefg</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>从逻辑角度来看， <code>null</code> 值表示一个空对象指针，指示变量未指向任何对象，常在返回类型是对象，但没关联值的地方使用，就像下面：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>); <span class="comment">// container是不存在的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($container); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>如果一个变量已经定义，并且它的值为 <code>null</code> ，那么他的类型就是：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(data)); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>你会发现他的类型并不是 <code>null</code>， 而是一个对象。这并不奇怪。从逻辑角度来看， <code>null</code> 值表示一个空对象指针，它代表的其实就是一个空对象。</p><h4 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h4><p>当你不知道该标记什么类型，或者你希望可以写任何类型时，可以谨慎使用 <code>any</code>，编译器将不会尝试对 <code>any</code> 类型的变量做任何的分析。</p><p> <code>any</code>  类型是目前 TypeScript 语言之中具有较大争议的一个设计，因为理论上我们可以将所有的变量声明为 <code>any</code> 从而绕过类型检查，这个时候 TypeScript 实际上退化为 JavaScript</p><p>但是考虑到目前 Web 前端项目会引用大量的第三方库，开发者很多时候无法完全把握某些变量的信息，所以 <code>any</code> 类型是必要的。不过我们需要注意其使用，对于能够给定类型的变量则尽量不标记为  <code>any</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">any</span> = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">num = <span class="number">2333</span>; <span class="comment">// OK</span></span><br><span class="line">num = <span class="literal">true</span>; <span class="comment">// OK</span></span><br><span class="line">num = <span class="literal">undefined</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h4 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h4><p>TypeScript 支持一种特殊的类型，即 <code>never</code> 类型。这种类型常被用于标注函数返回值，代表这个函数永远不会终结或者会抛出异常：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> neverEnd = (): <span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种类型的值永远不能被实例化，也即尝试声明和使用 <code>never</code> 类型的值将会总是出现错误，利用个特点，我们可以检测程序是否考虑了所有的情况，这被称为耗尽检查：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">All</span> = <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="comment">// switch 语句用法与 C/C++ 一致</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">value: All</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">typeof</span> value) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">let</span> <span class="attr">exhaustiveCheck</span>: <span class="built_in">never</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>never</code> 的特点，<code>default</code> 分支的代码执行必然会产生错误，因此如果该 <code>switch</code> 语句未能穷尽 <code>typeof value</code> 的可能取值，使得代码落入 <code>default</code> 分支，导致 <code>never</code> 类型的变量被实例化，进而导致编译器报错</p><p>如果修改类型 <code>All</code> 为 <code>number | string | boolean | undefined</code>，编译器会告诉我们<em>不能将类型“undefined”分配给类型“never”</em>，这就是因为当 <code>value === undefined</code> 时，会尝试将 <code>undefined</code> 赋给 <code>never</code> 类型的变量。 这样，<code>handler</code> 函数就会因为没有耗尽所有可能而报错</p><h2 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h2><p>声明变量时可以在变量后面标注类型，也可以根据初始值自动推断，但如果声明变量时不赋初始值，则必须添加类型标注，否则在使用时会报错（即自动推断该变量为 <code>undefined</code> 的类型，因此不能赋其他值）。</p><h4 id="普通类型标注"><a href="#普通类型标注" class="headerlink" title="普通类型标注"></a>普通类型标注</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Count</span>: <span class="built_in">number</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, TypeScript!&quot;</span>;</span><br></pre></td></tr></table></figure><p>也就是在变量名字后面紧接着跟一个冒号，再加上类型就可以了</p><p>但需要注意的是 TypeScript 允许使用字面量作为类型标注，如：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">one</span>: <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">one = <span class="number">2</span>;   <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>这里变量 <code>one</code> 的类型被限定为字面量 <code>1</code> 而不是所有的 <code>number</code>，这种标注的作用在下面会展示。</p><h4 id="对象和数组的标注"><a href="#对象和数组的标注" class="headerlink" title="对象和数组的标注"></a>对象和数组的标注</h4><p>对象：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="built_in">string</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;No. 2, Linggong Road, Ganjingzi District, Dalian City, Liaoning Province&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有元素均相同的数组：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;Embedded&#x27;</span>, <span class="string">&#x27;Web&#x27;</span>, <span class="string">&#x27;Media&#x27;</span>];</span><br><span class="line"></span><br><span class="line">learning_direction = <span class="string">&#x27;Web&#x27;</span>; <span class="comment">// Error! 不能将类型“string”分配给类型“string[]”</span></span><br><span class="line">learning_direction = [<span class="string">&#x27;Web&#x27;</span>]; <span class="comment">// Success</span></span><br></pre></td></tr></table></figure><p>固定长度和类型的数组：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: [<span class="built_in">number</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="literal">false</span>];</span><br></pre></td></tr></table></figure><h4 id="函数的标注"><a href="#函数的标注" class="headerlink" title="函数的标注"></a>函数的标注</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，函数名为 <code>sum</code>， 两个参数类型均为 <code>number</code> ，返回值也为 <code>number</code></p><p>这里要注意的是，编译器会尝试推断函数返回值，但<strong>不会尝试从函数实现中</strong>推断参数类型，因此参数列表的类型标注是必不可少的。</p><p>也可以按照声明变量的方式：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>sum</code> 作为一个变量，它的类型并非前文所提过的原始值，因此也是一个对象，它的构造函数是 <code>function</code></p><p>如果使用箭头函数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法的结果相同</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt; x + y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然我们函数参数有了类型的限制，但是实际上 TypeScript 在运行时并不会检查你的调用是否符合参数列表（尽管在编译器会尝试进行静态检查，但是如果你使用 <code>any</code> 或其他一些方法传入其他类型参数，仍然会继续运行）</p><p>在 JavaScript 中，甚至不会检查你函数调用的时候传入参数的个数，但是 TypeScript 会阻止传入个数错误的参数</p><p>在 TypeScript 中可以通过将参数标为可选或提供默认值来允许不同长度的传入参数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">1</span>, z?: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123; <span class="comment">// y的默认值是1，z为可选参数</span></span><br><span class="line">    <span class="keyword">return</span> x + y + (z ?? <span class="number">0</span>);  <span class="comment">// 这里 y 不可能为空值，但 z 可能。如果函数调用没有给出z，那么z默认是0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>));        <span class="comment">// =&gt; 1 + 1 + (undefined ?? 0) = 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">0</span>));     <span class="comment">// =&gt; 1 + 0 + (undefined ?? 0) = 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// =&gt; 1 + 2 + (3 ?? 0) = 6</span></span><br></pre></td></tr></table></figure><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>可以使用 <code>type</code> 关键词定义类型别名，在需要实现复杂的类型时非常有用：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> numberOne = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">one</span>: numberOne = <span class="number">1</span>;</span><br><span class="line">one = <span class="number">2</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><h4 id="联合类型和类型收窄"><a href="#联合类型和类型收窄" class="headerlink" title="联合类型和类型收窄"></a>联合类型和类型收窄</h4><p> TypeScript 可以将变量的类型声明为若干个类型之一，这称为联合类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">union</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">7</span>;</span><br><span class="line">union = <span class="string">&quot;Genshin Impact&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">union = <span class="number">8</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>上面的 <code>union</code> 变量，既可以是 <code>number</code> 类型，也可以是 <code>string</code> 类型</p><p>联合类型最常用的地方是标注函数参数，这样就允许了函数接受多种类型的参数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addHello = (<span class="attr">x</span>:<span class="built_in">number</span> | <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span> + x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addHello</span>(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">addHello</span>(<span class="string">&quot;Dalian&quot;</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>上文提到字面量可以作为类型标注，那么使用联合类型，就可以实现枚举行为：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> oddNumber = <span class="number">1</span> | <span class="number">3</span> | <span class="number">5</span> | <span class="number">7</span> | <span class="number">9</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: oddNumber = <span class="number">5</span>; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: oddNumber = <span class="number">2</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p><em>这就是上面提到的复杂类型之一</em></p><p>对于“所有元素均相同的数组”的实例代码出现的错误，如果更改为下面的代码：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] = [<span class="string">&#x27;Embedded&#x27;</span>, <span class="string">&#x27;Web&#x27;</span>, <span class="string">&#x27;Media&#x27;</span>];</span><br><span class="line"></span><br><span class="line">learning_direction = <span class="string">&#x27;Web&#x27;</span>; <span class="comment">// Success</span></span><br><span class="line">learning_direction = [<span class="string">&#x27;Web&#x27;</span>]; <span class="comment">// Success</span></span><br></pre></td></tr></table></figure><p>这里我们声明 <code>learning_direction</code> 可能有两种类型，即 <code>string</code> 和 <code>string[]</code>，所以我们可以将其任意赋值为其中的一种，但这就导致我们在使用这一值时，不能精确判断上面包含的方法，例如我们尝试执行：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learning_direction.<span class="title function_">match</span>(<span class="regexp">/react/</span>); <span class="comment">// Error! 类型“string[]”上不存在属性“match”</span></span><br></pre></td></tr></table></figure><p>这里编译器会报错，但如果我们的代码足以让编译器推断出来变量类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> learning_direction === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(learning_direcion.<span class="title function_">match</span>(<span class="regexp">/react/</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够进入 <code>if</code> 判断的第一个大括号的语句，那 <code>learning_direction</code> 就一定是 <code>string</code> 类型，编译器自己就能够明白，这么做是安全的，允许调用相应的方法，这种行为被称为<strong>类型收窄</strong></p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>这种语法只用在一种情况：你认为你比编译器还懂这个变量的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] = [<span class="string">&#x27;Embedded&#x27;</span>, <span class="string">&#x27;Web&#x27;</span>, <span class="string">&#x27;Media&#x27;</span>];</span><br><span class="line"></span><br><span class="line">(learning_direction <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">match</span>  (<span class="regexp">/react/</span>);</span><br></pre></td></tr></table></figure><p>我们这里使用 <code>as</code> 关键字，告诉编译器 <code>learning_direction</code> 这个变量一定为 <code>string</code> 类型，不可能是 <code>string[]</code> 类型，这个时候编译器就会听你的，把他它当作  <code>string</code> 类型处理</p><p>但你不能断言一个变量为明显冲突的类型</p><p>比如上述代码，如果是 <code>(learning_direction as string).match  (/react/);</code> ，那么就会报错，所以我们要先断言为 <code>unknown</code> 再断言为其他类型</p><h2 id="TypeScript-的复杂类型"><a href="#TypeScript-的复杂类型" class="headerlink" title="TypeScript 的复杂类型"></a>TypeScript 的复杂类型</h2><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>这类似于C++的模板</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数泛型</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是函数泛型</span></span><br><span class="line"><span class="keyword">const</span> identity = &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="function"><span class="params">Type</span> =&gt;</span> arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;<span class="title class_">NumType</span>&gt; &#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: <span class="title class_">NumType</span>;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象泛型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Request</span>&lt;<span class="title class_">ReqBody</span>, <span class="title class_">ResBody</span>&gt; &#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="title class_">ReqBody</span>;</span><br><span class="line">    <span class="attr">response</span>: <span class="title class_">ResBody</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别名泛型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MaybeArray</span>&lt;<span class="title class_">Value</span>&gt; = <span class="title class_">Value</span> | <span class="title class_">Value</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">//它们的实例化</span></span><br><span class="line">identity&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">req</span>: <span class="title class_">Request</span>&lt;&#123; <span class="attr">action</span>: <span class="built_in">string</span> &#125;, &#123; <span class="attr">result</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">    <span class="attr">request</span>: &#123;</span><br><span class="line">        <span class="attr">action</span>: <span class="string">&#x27;update system&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">response</span>: &#123;</span><br><span class="line">        <span class="attr">result</span>: <span class="string">&#x27;succeeded&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">nums</span>: <span class="title class_">MaybeArray</span>&lt;<span class="built_in">number</span>&gt; = <span class="number">0</span>;</span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>可以为泛型添加限制和默认值，也可以由编译器推断泛型类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span> = <span class="built_in">number</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identity</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">data</span>: <span class="built_in">string</span> &#125;&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identity</span>(&#123; <span class="attr">data</span>: <span class="string">&quot;str&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="typeof-和-keyof-关键字"><a href="#typeof-和-keyof-关键字" class="headerlink" title="typeof 和 keyof 关键字"></a>typeof 和 keyof 关键字</h4><p><code>typeof</code> 除了可以作为运算符获取变量类型以外，用作类型标注时，可以获取变量的具体类型（而非作为运算符时的有限种类）：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someObj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg: <span class="keyword">typeof</span> someObj</span>) &#123; <span class="comment">// arg: &#123; foo: number; bar: string &#125;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>keyof</code> 可以获取类型的键的类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg: keyof <span class="keyword">typeof</span> Obj</span>) &#123; <span class="comment">// arg: &#x27;foo&#x27; | &#x27;bar&#x27;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>与C语言的三目运算符语法相同，但是在 TypeScript 中与泛型结合会更有用</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">any</span> &#125; ? T[<span class="string">&#x27;message&#x27;</span>] : <span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;;  <span class="comment">// EmailMessageContents = string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Dog</span>&gt;;      <span class="comment">// DogMessageContents = unknown</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是TypeScript？&quot;&gt;&lt;a href=&quot;#什么是TypeScript？&quot; class=&quot;headerlink&quot; title=&quot;什么是TypeScript？&quot;&gt;&lt;/a&gt;什么是TypeScript？&lt;/h2&gt;&lt;p&gt;简而言之，TypeScript 是 JavaScript 的超集，它继承了 JavaScript 所有的语法，并且可以编译为纯 JavaScript 。它的目的并不是创造一种全新语言，而是增强 JavaScript 的功能，使其更适合多人合作的企业级项目。&lt;/p&gt;
&lt;p&gt;既然是超集，那么它&lt;strong&gt;超&lt;/strong&gt;在哪里呢？&lt;/p&gt;
&lt;p&gt;我们知道， JavaScript 的变量是没有类型的，无论用 &lt;code&gt;var, let, const&lt;/code&gt; 哪一个关键字，都无法指定变量的类型，因此我们称 JS 是一个“弱类型”的语言。例如下面的代码，在 JavaScript 中是完全合法的&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&amp;quot;34&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; res = a + str; &lt;span class=&quot;comment&quot;&gt;// res = &amp;quot;134&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这对我们来说是非常不好的，是反直觉的，正常人的思维应该是，一个数字和字符串怎么可能可以相加呢？这应该报错！&lt;/p&gt;
&lt;p&gt;TypeScript 最大的特点就是引入了类型系统，这样就可以在编译为 JavaScript 代码之前由编译器进行类型检查。在这样的条件下，TypeScript 中的变量在声明的时候就可以指定类型，编译器在将 TypeScript 代码编译为 JavaScript 代码的时候会进行类型检查，若有不符合类型声明的情况则会报错：&lt;/p&gt;
&lt;figure class=&quot;highlight tsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fun = (&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;): &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;void&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, &amp;quot;&lt;/span&gt; + name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title function_&quot;&gt;fun&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// Error!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的 &lt;code&gt;fun&lt;/code&gt; 函数要求传入一个 &lt;code&gt;string&lt;/code&gt; 类型的值，且返回类型为 &lt;code&gt;void&lt;/code&gt; 但是我们调用的时候却传入了一个数字2，这显然是不符合函数参数要求的，因此 TypeScript 编译器会报错&lt;/p&gt;
&lt;p&gt;TypeScript 有着静态类型检查，具有类型系统，可以在开发时捕获许多常见的错误。通过类型检查，可以在编码阶段就发现潜在的问题，减少运行时错误。因此我们更推荐使用 TypeScript 进行项目开发，而不是 JavaScript&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>现代前端开发基础</title>
    <link href="https://houyi2333.github.io/2024/01/20/12-33-21/"/>
    <id>https://houyi2333.github.io/2024/01/20/12-33-21/</id>
    <published>2024-01-20T04:33:21.000Z</published>
    <updated>2024-01-23T13:42:11.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="库和框架"><a href="#库和框架" class="headerlink" title="库和框架"></a>库和框架</h2><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>库是一系列预先定义好的数据结构和函数或类的集合，程序员可以通过调用这些代码实现功能。简单来说就是库为我们提供了很多封装好的函数，看起来比较零散，但使用起来更灵活，只用取里面我们需要的某部分，再自己实现项目中其他部分得功能</p><p>库就类似于 C 语言中的头文件，比如 <code>&lt;stdio.h&gt;</code> 头文件提供了一系列常用的功能：<code>printf()</code>、<code>scanf()</code>、<code>gets()</code>、<code>fopen()</code> 等</p><p>在前端开发中，使用库可以简化开发流程，提高开发效率。例如，jQuery 提供了简化 DOM 操作的语法，减少了编写繁琐代码的需要。React 通过虚拟 DOM 和声明式 UI ，便于快速构建用户界面</p><p>如果需要在网页中使用 JavaScript 库，可以去网上下载库文件，放在网页的同一目录下，再到<code>script</code>标签中引入。或者不下载通过通过链接在<code>&lt;script&gt;</code>标签中引用该库即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/3.4.0/jquery.min.js&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在代码中通过 <code>require</code> 或者 <code>import</code> 中引入库。在现代的前端开发中，通常推荐使用 <code>import</code> 来进行模块导入，特别是在使用现代 JavaScript 特性的项目中。这主要与现代 JavaScript的发展趋势和语言特性有关</p><p><code>import</code> 是 ES6 新引入的关键字，支持按需导入，而不需要导入整个模块。同时<code>require</code> 的语法也比 <code>import</code> 更直观清晰，更符合现代变成风格</p><p>随着 JavaScript 生态的发展，越来越多的库和工具采用了 ES6 模块系统，使用 <code>import</code> 能够更好地与这些现代化的工具和库进行集成。</p><span id="more"></span><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>框架是提供如何构建应用程序的意见的库，是一整套的工具，所有东西已经准备齐全了，可以按照它的规定就可以很简单的完成一些事情，但我们不能去改变它，只能按照要求使用，并且其他人拿到这套工具也是一样的，如 Vue、Angular 等等。</p><p>注意是一套而不是单个，比如 React 就是一个库，它本身只是一个前端渲染的库，纯粹地写 UI 组件，没有什么异步处理机制、模块化等，但是当它结合 Redux 和 React-router 的时候，就是一个框架了。</p><p>框架和库的联系紧密，都是为了提高我们的开发效率而存在，库的使用上会简单一些，更加灵活，但功能不全。而框架的功能很全面，但需要我们按规定去使用。也就是说库是一种工具，我提供了，你可以不用，即使你用了，也没影响你自己的代码结构，控制权在使用者手中。框架则是面向一个领域，提供了一套解决方案，如果你用我，就得按照我的方式办事，控制权在框架本身</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>库是一组已经实现的代码集合，提供了特定功能的函数和方法，开发者可以根据需要选择性地使用。库不控制应用程序的整体架构，而是为开发者提供了可调用的工具，以便在应用程序中实现特定功能</p><p>框架是一种提供了一整套解决方案的软件结构，它规定了整个应用程序的架构，定义了组织代码的方式，并提供了一系列工具和库，以便开发者可以在框架的基础上构建应用。框架通常有一个完整的生命周期，控制着应用程序的流程，开发者需要按照框架的规则来编写代码。</p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h4 id="什么是-Node-js"><a href="#什么是-Node-js" class="headerlink" title="什么是 Node.js"></a>什么是 Node.js</h4><p>JavaScript 是一个脚本语言，最初用来处理网页中的一些动态功能和一些用户行为。它一般运行于浏览器</p><p>但是这门语言后续不断更新，越来越多的人开始使用 JavaScript 。为了把它迁移到了服务端，但服务端上又不能跑浏览器，那我们就需要一种新的运行环境。就这样， Node.js 诞生了</p><h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><p>打开 Node.js 的官网<a href="http://www.nodejs.org">链接</a></p><p>单击左侧的 LTS 版本进行下载</p><p><img src="/2024/01/20/12-33-21/image-20240123155049028.png" alt="image-20240123155049028"></p><p>安装过程没什么好说的，一路下一步</p><p><img src="/2024/01/20/12-33-21/image-20240123155413105.png" alt="image-20240123155413105"></p><p>之后我们就可以在终端中执行 <code>node</code>命令编译运行 <code>.js</code> 文件</p><p><img src="/2024/01/20/12-33-21/image-20240123155752568.png" alt="image-20240123155752568"></p><p>使用命令 <code>npm init</code> 可以将当前文件夹初始化为一个 Node.js 项目</p><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a><code>npm</code></h4><p><code>npm</code>（Node Package Manager）是一个用于管理和分享 JavaScript 包的工具，专门用于在服务器端和命令行工具中管理 JavaScript 包。它是随同 Node.js 安装的包管理工具，安装好node之后就会默认安装好npm了</p><p>JavaScript 包是一种封装了代码、资源的组织形式，能够方便共享、安装和管理代码。这些包可以包含 JavaScript 库、框架、工具或应用程序等。而 <code>npm</code> 就是管理这些包的工具（当然除了 <code>npm</code> 也有其他工具，比如 <code>yarn</code>、<code>yum</code>等）</p><p>我们可以在命令行中输入 <code>npm -v</code> 判断是否安装了 <code>npm</code></p><p><img src="/2024/01/20/12-33-21/image-20240123213514850.png" alt="image-20240123213514850"></p><p>如果成功获取到了版本号，说明 <code>npm</code> 已经成功的安装在您的电脑中了</p><h5 id="npm-的常见命令"><a href="#npm-的常见命令" class="headerlink" title="npm 的常见命令"></a><code>npm</code> 的常见命令</h5><p><code>npm install &lt;Module Name&gt;</code> 使用 <code>npm</code> 命令本地安装模块</p><p><code>npm install -g &lt;Module Name&gt;</code> 全局安装</p><p>两个的区别就是本地安装将安装包放在当前文件夹的 <code>node_modules</code> （如果没有则会自动生成）文件夹下，通过 <code>import</code> 来引入本地安装的包；全局安装包则通常放在 <code>node</code> 的安装目录下，可以直接在命令行里使用</p><p><code>npm uninstall &lt;Name&gt;</code> 卸载模块</p><p><code>npm install -g npm@&lt;版本号&gt;</code> 更新 <code>npm</code></p><p><code>npm publish</code> 将自己的代码发布到 <code>npm</code> 上的全球开源库中</p><h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h5><p><code>package.json</code> 是 Node.js 项目中的一个重要文件，它用于存储项目的配置信息。包含了项目的元数据（metadata），如项目名称、版本、作者、依赖库等信息。通过描述项目上下文、所需依赖和开发脚本，使项目具备可重复性和可移植性</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;learn_react&quot;</span><span class="punctuation">,</span> <span class="comment">// 项目的名称</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.1.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 项目的版本号</span></span><br><span class="line">    <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 用于指示是否将该项目发布到公共的包注册表的标志</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 项目运行时所依赖的第三方包</span></span><br><span class="line">        <span class="attr">&quot;@testing-library/jest-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.14.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@testing-library/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^13.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@testing-library/user-event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^13.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@types/jest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^27.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@types/node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^16.7.13&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@types/react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;react-scripts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.4.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;web-vitals&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.1.0&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义一组自定义的命令脚本</span></span><br><span class="line">        <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts start&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts build&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts test&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 用于指定项目所支持的目标浏览器范围的配置文件，通常用于前端开发</span></span><br><span class="line">        <span class="attr">&quot;production&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;&gt;0.2%&quot;</span><span class="punctuation">,</span> <span class="comment">// 支持全球使用率超过0.2%的浏览器</span></span><br><span class="line">            <span class="string">&quot;not dead&quot;</span><span class="punctuation">,</span> <span class="comment">// 排除已经被官方宣布为不再更新的浏览器</span></span><br><span class="line">            <span class="string">&quot;not op_mini all&quot;</span> <span class="comment">// 用于排除 Opera Mini 浏览器，Opera Mini 具有一些独特的行为或限制，需要在项目中进行特殊处理</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;development&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;last 1 chrome version&quot;</span><span class="punctuation">,</span> <span class="comment">// 支持每个浏览器的最后一个版本</span></span><br><span class="line">            <span class="string">&quot;last 1 firefox version&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果项目有 <code>package.json</code> 文件，则通过命令 <code>npm install</code> 可以根据 <code>&quot;dependencies&quot;</code> 自动在 <code>node_modules</code> 文件夹中安装项目所需的所有包</p><h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><p>在计算机编程中，模块是指一个相对独立的程序文件或代码库，通常包含一组相关的函数、变量、类或其他可重用的代码构件，每个模块在内部执行某个功能。并向外部公开一定的接口以供其他模块使用。在编程语言中，通常有一些标准库或第三方库，这些库都是由多个模块组成的，可以在程序中被引用和使用。模块化主要是为了帮助程序员组织和管理大型代码库，可以将大型的程序有逻辑地拆分成一个个相对较小的部分，实现代码复用，让程序设计更加灵活，使其更易于维护和扩展。这是优点之一。并且还可以避免变量名和函数名命名冲突的问题以及解决不同模块之间的依赖关系。</p><p>就比如我要写一个贪吃蛇小游戏，普通代码编写就把所有逻辑像画布渲染，蛇的运动，食物的随机出现等都写到一个文件里，如果使用模块化概念，我们可以简单分块，分成主文件，蛇以及食物三个，然后在各个文件里实现相应的逻辑，这样假如你发现蛇的运动有问题，你就可以去蛇那个文件查找运动控制函数有没有问题，或者主文件中画布渲染有没有问题，这样感觉就更简单一点，目的更明确，更好地去维护。</p><p><code>import</code> 和 <code>export</code> 是 ES6 引入的模块系统的关键字，用于在 JavaScript 中进行模块化编程。模块化使得代码更结构化、可维护，并允许开发者将代码分割为小的可重用部分</p><h4 id="export-的使用："><a href="#export-的使用：" class="headerlink" title="export 的使用："></a><code>export</code> 的使用：</h4><p><code>export</code> 用于将变量、函数、类或其他声明导出为模块的公共接口，以便其他模块可以使用。有三种常见的 <code>export</code> 的方式</p><h5 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h5><p>可以通过 <code>export</code> 关键字单独导出多个成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h5><p>通过 <code>export default</code> 关键字导出一个默认成员，每个模块只能有<strong>一个</strong>默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myVariable;</span><br></pre></td></tr></table></figure><h5 id="导出声明"><a href="#导出声明" class="headerlink" title="导出声明"></a>导出声明</h5><p>在声明时使用 <code>export</code> 关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><h4 id="import-的使用："><a href="#import-的使用：" class="headerlink" title="import 的使用："></a><code>import</code> 的使用：</h4><p><code>import</code> 用于在一个模块中引入其他模块导出的成员，以便在当前模块中使用。有三种常见的 <code>import</code> 的方式：</p><h5 id="命名导入"><a href="#命名导入" class="headerlink" title="命名导入"></a>命名导入</h5><p>导入其他模块中的命名导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myVariable, myFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h5><p> 导入其他模块中的默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> myVariable <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="导入所有"><a href="#导入所有" class="headerlink" title="导入所有"></a>导入所有</h5><p>导入其他模块的所有导出，形成一个命名空间对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> internalVariable = <span class="string">&#x27;internal&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> internalVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myVariable, myFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myVariable); <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">myFunction</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> internalVariable <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(internalVariable); <span class="comment">// &#x27;internal&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">myVariable</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>打包是指将多个模块（ JavaScript、CSS、图片等）打包成为一个文件，这有助于代码管理、发布和使用。在前端开发中，通常需要使用打包工具将代码打包成浏览器可识别的格式，并优化加载速度和性能。</p><p>为什么前端需要打包？以前的前端开发存在三个大问题：没有模块化、第三方包的引入繁琐困难、代码以明文形式展示出来</p><p>我们利用打包工具就可以实现：支持模块化、自动打包第三方包、代码混淆，使得其他人无法阅读</p><p>下面介绍两个常使用的与打包有关的工具</p><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>Babel 是一个 JavaScript 编译器，它能够将 ECMAScript 2015+ 的新特性转换为向后兼容的 JavaScript 代码，例如将 ES6 的箭头函数转换为普通函数、将模板字符串转换为常规字符串等等，使得我们可以在现代浏览器中使用最新的 JavaScript 特性，从而解决浏览器兼容性问题</p><p>执行 <code>npm install -g babel-cli</code> 安装 Babel</p><p>在项目根目录创建 <code>.babelrc</code> 文件，这是 Babel 的配置文件，并编写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;es2015&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>执行 <code>npm install babel-preset-es2015</code> 安装转码器，就是从源码转到老版本的代码中间的语法映射表</p><p>在根目录创建 <code>src</code> 文件夹，新建 <code>index.js</code> 并编写如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">[a, b, c] = [b, c, a + <span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br></pre></td></tr></table></figure><p>这里用到了 ES6 的新特性解构赋值，执行 <code>babel src -d dist</code> Babel 就能够将它转换为旧的 ES2015 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./dist/index.js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> _ref = [b, c, a + <span class="number">1</span>];</span><br><span class="line">a = _ref[<span class="number">0</span>];</span><br><span class="line">b = _ref[<span class="number">1</span>];</span><br><span class="line">c = _ref[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);</span><br></pre></td></tr></table></figure><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>Webpack 是一个模块打包工具，它可以将多个模块打包成一个或多个 JavaScript 文件，而这些 JavaScript 文件可以被浏览器正确加载执行。Webpack 可以处理各种类型的资源文件，如 JS、CSS、图片等，并提供了各种插件和 loader 用于对不同类型的资源进行处理和优化，同时还支持热更新功能，方便开发人员进行调试和开发</p><p>Webpack 会隐藏源码的细节，把多个 JavaScript 合并成一个 JavaScript，提高浏览器的访问速度，使源码更加安全</p><p>执行 <code>npm install -g webpack webpack-cli</code> 安装 Webpack</p><p>修改 <code>src</code> 下的 <code>index.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">[a, b, c] = [b, c, a + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr = [a, b, c];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> arr;</span><br></pre></td></tr></table></figure><p>在 <code>src</code> 下新建 <code>main.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="keyword">import</span> arr <span class="keyword">from</span> <span class="string">&quot;./index.js&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p>在根目录下定义一个 <code>webpack.config.js</code> 文件配置打包规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入path模块,nodejs的内置模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">//定义JS打包的规则</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//指定构建的模式</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="comment">//入口函数从哪里开始进行编译打包</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="comment">//编译成功以后要把内容输出到那里去</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//定义输出的指定的目录__dirname 当前项目根目录，将生成一个dist文件夹</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">        <span class="comment">//合并的js文件存储在dist/bundle.js文件中</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>终端执行 <code>webpack</code> 即可在 <code>dist</code> 文件夹中看到生成的 <code>bundle.js</code>，这就是合并后的 JavaScript 代码</p><p>通常在前端项目中，我们会将 Babel 和 Webpack 结合使用，使用 Babel 将最新版本的语法转换成向后兼容的代码，再由 Webpack 将这些代码打包并优化，最终生成浏览器可以解析的文件。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;库和框架&quot;&gt;&lt;a href=&quot;#库和框架&quot; class=&quot;headerlink&quot; title=&quot;库和框架&quot;&gt;&lt;/a&gt;库和框架&lt;/h2&gt;&lt;h4 id=&quot;库&quot;&gt;&lt;a href=&quot;#库&quot; class=&quot;headerlink&quot; title=&quot;库&quot;&gt;&lt;/a&gt;库&lt;/h4&gt;&lt;p&gt;库是一系列预先定义好的数据结构和函数或类的集合，程序员可以通过调用这些代码实现功能。简单来说就是库为我们提供了很多封装好的函数，看起来比较零散，但使用起来更灵活，只用取里面我们需要的某部分，再自己实现项目中其他部分得功能&lt;/p&gt;
&lt;p&gt;库就类似于 C 语言中的头文件，比如 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; 头文件提供了一系列常用的功能：&lt;code&gt;printf()&lt;/code&gt;、&lt;code&gt;scanf()&lt;/code&gt;、&lt;code&gt;gets()&lt;/code&gt;、&lt;code&gt;fopen()&lt;/code&gt; 等&lt;/p&gt;
&lt;p&gt;在前端开发中，使用库可以简化开发流程，提高开发效率。例如，jQuery 提供了简化 DOM 操作的语法，减少了编写繁琐代码的需要。React 通过虚拟 DOM 和声明式 UI ，便于快速构建用户界面&lt;/p&gt;
&lt;p&gt;如果需要在网页中使用 JavaScript 库，可以去网上下载库文件，放在网页的同一目录下，再到&lt;code&gt;script&lt;/code&gt;标签中引入。或者不下载通过通过链接在&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中引用该库即可：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;https://cdn.staticfile.org/jquery/3.4.0/jquery.min.js&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者在代码中通过 &lt;code&gt;require&lt;/code&gt; 或者 &lt;code&gt;import&lt;/code&gt; 中引入库。在现代的前端开发中，通常推荐使用 &lt;code&gt;import&lt;/code&gt; 来进行模块导入，特别是在使用现代 JavaScript 特性的项目中。这主要与现代 JavaScript的发展趋势和语言特性有关&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 是 ES6 新引入的关键字，支持按需导入，而不需要导入整个模块。同时&lt;code&gt;require&lt;/code&gt; 的语法也比 &lt;code&gt;import&lt;/code&gt; 更直观清晰，更符合现代变成风格&lt;/p&gt;
&lt;p&gt;随着 JavaScript 生态的发展，越来越多的库和工具采用了 ES6 模块系统，使用 &lt;code&gt;import&lt;/code&gt; 能够更好地与这些现代化的工具和库进行集成。&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1_什么是线性、什么是线性代数</title>
    <link href="https://houyi2333.github.io/2024/01/09/14-54-42/"/>
    <id>https://houyi2333.github.io/2024/01/09/14-54-42/</id>
    <published>2024-01-09T06:54:42.000Z</published>
    <updated>2024-01-22T06:23:31.178Z</updated>
    
    <content type="html"><![CDATA[<p>线性代数作为大学里最重要的数学基础课之一，是大批学生的噩梦。相较而言，高数虽然内容繁杂，各种奇技淫巧频频出现，但由于高中课程中对导数等概念和相应工具的启蒙，且涉及微积分基本思想的数学故事也不少，加上近年来不少民科对微积分的攻击也帮助了一些简单微积分知识的普及，因而理工科的高数类课程反而不会让人觉得难以理解。</p><p>线性代数则不然，它往往让不少人从翻开书的第一页起一直懵逼到期末，讲的都是些什么玩意儿？ 最后迫不得已，一夜刷尽往年卷，匆匆应对期末考，从此相见不相识。</p><p>总的来说，教材的大致思路是先以某种方式定义矩阵，然后引入行列式，立马就开始计算。先对矩阵各种算——左乘右乘左右乘、求逆求秩求幂方，接着就开始了迷之特征值和向量空间，还有相似对角和相合，画风相当凌乱，根本不知道线性代数到底是什么，反正就是求和算。</p><p>这门课我也上完一年多了，最近也用到了很多线代中的知识，越发体会到这门课的重要性，于是准备把他重新捡起来，一边学一边讲解自己对线代的理解。</p><span id="more"></span><hr><p><strong><em>以下是正文：</em></strong></p><p>这是《线性代数》这一章的第一篇文档，本篇不会讲线代的具体内容，仅会对线性代数进行一个介绍</p><p>什么是线性？我们考虑这样一个初中问题</p><script type="math/tex; mode=display">求方程组\left\{ \begin{array}{l}    2x-y=0\\    -x+2y=3\\\end{array} \right.的解</script><p>我们先抛开代数消元不谈，从几何上我们可以这么理解这个问题</p><script type="math/tex; mode=display">求直线2x-y=0和直线-x+2y=3的交点的坐标</script><p><img src="/2024/01/09/14-54-42/image-20240109150913411.png" alt="image-20240109150913411"></p><p>显然交点的坐标为$(1,2)$，所以方程组的解为$x=1, y=2$</p><p>那么我们还知道，这个方程组叫做线性方程组，为什么呢？因为这个方程组的所有方程都是线性方程。什么是线性方程呢？我们把形如$a_1x_1+a_2x_2+\cdots+a_nx_n=b$的方程叫做线性方程，因为他表示了n维空间内的一个……，我也不知道，我只知道二元一次方程就表示了二维平面内的一条直线，三元一次方程就表示了三维空间内的一个平面。反正我无法想象三维以上的空间。</p><p>线性方程组是由一个或多个包含相同变量的未知数的线性方程组成的，其一般形式为：</p><script type="math/tex; mode=display">\left\{ \begin{array}{l}    a_{11}x_1+a_{12}x_2+\cdots +a_{1n}x_n=b_1\\    a_{21}x_1+a_{22}x_2+\cdots +a_{2n}x_n=b_2\\    \vdots\\    a_{m1}x_1+a_{m2}x_2+\cdots +a_{mn}x_n=b_m\\\end{array} \right.</script><p>这是m个n元一次方程，表示了n维空间内的一个……，嗯，就是那个……</p><p>现在我们再回到上面那个初中问题，如果把这个方程组竖着看会怎么样</p><script type="math/tex; mode=display">已知\vec{a}=\left( 2,-1 \right) ，\vec{b}=\left( -1,2 \right) ，\vec{c}=\left( 0,3 \right)，求实数x、y，使得x\vec{a}+y\vec{b}=\vec{c}</script><p>它变成了一个平面二维向量的组合问题，对$\vec{a}$和$\vec{b}$进行一个线性组合，使其能够得到$\vec{c}$。什么是线性组合？它的定义是这样的</p><script type="math/tex; mode=display">对于若干个n维向量：\vec{a_1}, \vec{a_2}, \cdots, \vec{a_m}\\对每个向量都乘上一个系数后相加：k_1\vec{a_1}+k_2\vec{a_2}+\cdots+\vec{a_m}k_m=\vec{b}\\我们称\vec{b}是这若干个n维向量的一个线性组合，也叫做线性表示</script><p>对于上面的初中问题，让x取1，y取2就可以成功组合出来$(0, 3)$这个向量</p><p>现在我们思考另一个问题，所有的线性组合是什么？这种问题在这门课中会频繁出现。选取所有的x和y，所有的组合，结果是你会得到任意的二维向量，也就是对这两个向量进行不同的线性组合可以得到所有平面向量，这是我们高中学过的平面向量基本定理。这种线性组合的思想，是线性代数这门课的基础</p><p>接下来我们考虑三个方程三个未知数的方程组</p><script type="math/tex; mode=display">求方程组\left\{ \begin{array}{l}    2x-y=0\\    -x+2y-z=-1\\    -3y+4z=4\\\end{array} \right.的解</script><p>我们先把这个方程横着看，这是三维空间中的三个平面相交，求交点的坐标</p><p>如果把这个方程竖着看，那就是三维空间的三个向量的线性组合，使其能够组合出来等号右边的向量</p><p>现在我们思考另一个问题，所有的线性组合是什么？这是我们高中学过的空间向量基本定理，对于三个不共面的三维向量，其线性组合可以覆盖到整个三维空间。如果有两个向量位于同一个平面，那这两个向量中的一个将对向量组毫无贡献，这样的线性组合就只能覆盖到一个二维平面</p><p>那大家是否能想象出来四维空间中4个向量的组合，n维空间中n个向量的组合？显然，我们想象不出来。但在学完线性代数这门课以后，我们就会意识到，这n个向量有机会覆盖到整个n维空间。这很难直观的想象出来，我们也可以说这是某种平面。如果这n个向量中有两个向量是“共面”的，那么这n个向量就只能覆盖到n维空间中的某n-1维平面，最后的求解也只能在这n-1维平面上展开</p><p>线性代数是数学的一个分支，它的研究对象是向量，向量空间（或称线性空间），线性变换和有限维的线性方程组。这些概念和方法在数学、物理学、工程学、计算机等领域中都有广泛的应用。例如，在数学中，线性代数被广泛地应用于抽象代数和泛函分析中；在计算机领域中，线性代数被广泛地应用于计算机图形学、密码学、计算机视觉等方面</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;线性代数作为大学里最重要的数学基础课之一，是大批学生的噩梦。相较而言，高数虽然内容繁杂，各种奇技淫巧频频出现，但由于高中课程中对导数等概念和相应工具的启蒙，且涉及微积分基本思想的数学故事也不少，加上近年来不少民科对微积分的攻击也帮助了一些简单微积分知识的普及，因而理工科的高数类课程反而不会让人觉得难以理解。&lt;/p&gt;
&lt;p&gt;线性代数则不然，它往往让不少人从翻开书的第一页起一直懵逼到期末，讲的都是些什么玩意儿？ 最后迫不得已，一夜刷尽往年卷，匆匆应对期末考，从此相见不相识。&lt;/p&gt;
&lt;p&gt;总的来说，教材的大致思路是先以某种方式定义矩阵，然后引入行列式，立马就开始计算。先对矩阵各种算——左乘右乘左右乘、求逆求秩求幂方，接着就开始了迷之特征值和向量空间，还有相似对角和相合，画风相当凌乱，根本不知道线性代数到底是什么，反正就是求和算。&lt;/p&gt;
&lt;p&gt;这门课我也上完一年多了，最近也用到了很多线代中的知识，越发体会到这门课的重要性，于是准备把他重新捡起来，一边学一边讲解自己对线代的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="线性代数" scheme="https://houyi2333.github.io/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>唉，计组</title>
    <link href="https://houyi2333.github.io/2024/01/07/17-04-19/"/>
    <id>https://houyi2333.github.io/2024/01/07/17-04-19/</id>
    <published>2024-01-07T09:04:19.000Z</published>
    <updated>2024-01-22T11:53:31.849Z</updated>
    
    <content type="html"><![CDATA[<p>今天是个特殊的日子：赖晓晨的计组出分了</p><p>好消息是分数还不错，在期末考试几乎没有会的题的情况下竟然拿到了80分，这说明赖晓晨在中等成绩段上给分还是不错的</p><p>听说去年最高分也只有88分，可能确实是在他手上很难拿高分吧</p><span id="more"></span><hr><p><strong><em>以下是正文：</em></strong></p><p>首先恭喜同学成功的选上了赖晓晨老师的计算机组织与结构这门课</p><p>赖晓晨非常喜欢华为这个企业，上课会穿插极其多的华为的内容，期末考试也会涉及一些华为的内容，尤其是华为的鲲鹏处理器</p><p>赖晓晨老师上课的流程是，先扫码进雨课堂，课中会时不时在雨课堂发送测试题，并且每道题只有 30-60s 的时间来作答，如果翘课是很难通过别人提醒来及时作答的。同时，课上还会提问坐在后排的学生，如果没答上来，还会要求该学生坐到第一排。后来你会发现，教室里只有前5排有学生，后面一个都没有。同时，上课抢答的同学会记名，加平时分。同时，还会有翻转课堂，也就是学生讲课，自愿报名，报名的加平时分。同时，成绩构成也很复杂，各种形式五花八门，给大家看一下成绩构成</p><p><img src="/2024/01/07/17-04-19/image-20240107170838300.png" alt="image-20240107170838300"></p><p>课后作业包括两部分，一部分是课本课后习题，会挑一些做，这个没什么问题，量也不多，与其他老师都一样。但是其他老师的平时成绩也就是这些课后习题了，而赖晓晨老师为了让学生全面发展，课后作业又新增了一项——代码作业</p><p>代码作业我这一届是有5个，如下图：</p><p><img src="/2024/01/07/17-04-19/image-20240107170921333.png" alt="image-20240107170921333"></p><p>这个代码作业是线上提交C语言代码，但是这个代码的难度。。。反正我写不出来，并且ChatGPT也写不出来。作业的1003，我的代码通过了课本所有的例题，但是就是通不过他给的样例，最后喜提75分</p><p>同时，这个作业的代码会进行查重，如果你跟另一个同学的代码相似度过高，两个人本次作业会被直接判为0分。</p><p>同时，赖晓晨老师还设置了课内实验和微认证这两个部分</p><p>课内实验是什么呢，是赖晓晨老师亲手写的<strong>122页</strong>PDF，这个PDF教给了你如何租用华为鲲鹏920服务器，如何使用open Euler操作系统，如何编写ARMV8汇编程序，如何对汇编代码进行优化等等内容，并且还有每一个实验都紧跟着一个思考题，每一个实验不做思考题大概耗时1.5h。但是如果考虑到用电脑时诸如水群和看视频等其他操作，可能需要一晚上甚至更多时间才能做完一个实验。总共有5个实验需要做。</p><p>这个实验对于没有服务器租用经验和Linux系统使用经验的同学来说，我个人认为还是有挑战性的，open Euler是一个没有GUI的操作系统，仅能使用shell命令和vim编辑器进行操作</p><p>接下来讲微认证的5分</p><p>这个微认证的内容是华为鲲鹏处理器知识，有很多的课可以选，只要完成必做的一个+任选一个，共完成两个，就可以拿到这五分</p><p><img src="/2024/01/07/17-04-19/image-20240107171104951.png" alt="image-20240107171104951"></p><p><img src="/2024/01/07/17-04-19/image-20240107171643108.png" alt="image-20240107171643108"><img src="/2024/01/07/17-04-19/image-20240107171650661.png" alt="image-20240107171650661"></p><p>这个微认证，每个课都是需要花费一张代金券的，代金券一个周能且仅能领一张，且限量500张，如果被抢没了，那这个周你想做也做不了了</p><p>当然，上述还没有考虑到大作业，当然大作业是选做的，也不知道做大作业是更容易及格还是更不容易及格</p><p>大作业的要求是，根据那<strong>122页</strong>PDF给出的实验，自己创新性的提出新的实验，实验内容要求与鲲鹏处理器技术的内容高度相关，实验文档的结构也要与实验手册一致，包括实验目的、实验设备、实验原理、实验任务操作指导以及思考题。由于我们并没有深入学习过鲲鹏920处理器，也不了解ARMV8架构和Linux操作系统，也不了解处理器内部结构，个人认为想要设计这个实验还是很难的，虽然我当年选择了做大作业，自己设计了一个实验）</p><p>大作业也不像其他老师一样交上去就完事了，需要三个人一起组队完成，要开题答辩，最终答辩，开题答辩还需要刷人，最终答辩如果不理想也要被刷掉。被刷掉了成绩构成就要回归第一种方案，也就是没有大作业，所以即使做了大作业，赖晓晨老师也不一定会让允许你的大作业计入期末成绩，可能会前功尽弃。</p><p>本人对赖晓晨老师的评价是，讲课极其认真，如果认真完成每一个作业，真的可以学到很多在其他老师课堂上学不到的东西，但是从成绩的角度讲，确实不容易拿到很高的分数。并且选他的课事情会极其极其极其的多，想摆烂求及格的同学千万不要选，会忙的你痛不欲生</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天是个特殊的日子：赖晓晨的计组出分了&lt;/p&gt;
&lt;p&gt;好消息是分数还不错，在期末考试几乎没有会的题的情况下竟然拿到了80分，这说明赖晓晨在中等成绩段上给分还是不错的&lt;/p&gt;
&lt;p&gt;听说去年最高分也只有88分，可能确实是在他手上很难拿高分吧&lt;/p&gt;</summary>
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>具体数学笔记</title>
    <link href="https://houyi2333.github.io/2024/01/04/18-38-27/"/>
    <id>https://houyi2333.github.io/2024/01/04/18-38-27/</id>
    <published>2024-01-04T10:38:27.000Z</published>
    <updated>2024-01-22T11:48:36.066Z</updated>
    
    <content type="html"><![CDATA[<p>这门课在大工只有软院开，并且极其的抽象，虽然他叫具体数学</p><p>这门课的虽然很抽象，但是考试很简单，全部源自 PPT 和作业题，几乎连数都不变</p><p>这里在知识点上进行了一下总结（其实就是把 PPT 用人话说了一遍），建议先看会知识点，再看 PPT 的题，再看作业题</p><p>下载链接：<a href="./note.pdf" download>具体数学笔记</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这门课在大工只有软院开，并且极其的抽象，虽然他叫具体数学&lt;/p&gt;
&lt;p&gt;这门课的虽然很抽象，但是考试很简单，全部源自 PPT 和作业题，几乎连数都不变&lt;/p&gt;
&lt;p&gt;这里在知识点上进行了一下总结（其实就是把 PPT 用人话说了一遍），建议先看会知识点，再看 PPT 的题，再</summary>
      
    
    
    
    <category term="具体数学" scheme="https://houyi2333.github.io/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>VSCode自动格式化.c and .cpp文件并开启自动保存</title>
    <link href="https://houyi2333.github.io/2023/10/06/13-11-21/"/>
    <id>https://houyi2333.github.io/2023/10/06/13-11-21/</id>
    <published>2023-10-06T05:11:21.000Z</published>
    <updated>2024-01-27T10:54:48.175Z</updated>
    
    <content type="html"><![CDATA[<p>打开 VSCode 的设置，搜索 Format ，将搜索到的选项设置成如下格式，这样就打开了自动格式化</p><p><img src="/2023/10/06/13-11-21/3cfc97729ba949edbac614d0d90e00b1.png" alt="3cfc97729ba949edbac614d0d90e00b1"></p><span id="more"></span><p>在设置中搜索 Auto Save ，将 <code>Files: Auto Save</code> 改为 <code>onFocusChange</code>，这样就开启了自动保存</p><p><img src="/2023/10/06/13-11-21/36e4dcbc98ac4282a2359ca9da791d36.png" alt="36e4dcbc98ac4282a2359ca9da791d36"><br>还有一个让强迫症患者很头大的问题：大括号是换行还是不换行？</p><p><img src="/2023/10/06/13-11-21/00224dc01a8e4a72a668a8e10456ec2c.png" alt="00224dc01a8e4a72a668a8e10456ec2c"><br>在设置中搜索 C_Cpp.Clang_format_style ，填入 <code>&#123;BasedOnStyle: Chromium, IndentWidth: 4&#125;</code> </p><p><img src="/2023/10/06/13-11-21/f57336ae3841440183321d629da7b7d9.png" alt="f57336ae3841440183321d629da7b7d9"><br>这样大括号就不会换行</p><p><img src="/2023/10/06/13-11-21/899708edb6dd4be0b39371828a9f8ec2.png" alt="899708edb6dd4be0b39371828a9f8ec2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打开 VSCode 的设置，搜索 Format ，将搜索到的选项设置成如下格式，这样就打开了自动格式化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/10/06/13-11-21/3cfc97729ba949edbac614d0d90e00b1.png&quot; alt=&quot;3cfc97729ba949edbac614d0d90e00b1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="VSCode" scheme="https://houyi2333.github.io/categories/VSCode/"/>
    
    
  </entry>
  
  <entry>
    <title>大连理工大学软件学院新生学习指南</title>
    <link href="https://houyi2333.github.io/2023/09/22/20-57-01/"/>
    <id>https://houyi2333.github.io/2023/09/22/20-57-01/</id>
    <published>2023-09-22T12:57:01.000Z</published>
    <updated>2024-01-22T06:29:05.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大一上学期课程简介以及成绩计算相关"><a href="#大一上学期课程简介以及成绩计算相关" class="headerlink" title="大一上学期课程简介以及成绩计算相关"></a>大一上学期课程简介以及成绩计算相关</h2><p>软件学院大一上学期的课程有：大学生心理健康教育（<strong>2 学分</strong>）、大学英语 1（<strong>2 学分</strong>）、健康教育（<strong>0.5 学分</strong>）、计算机系统实践（<strong>1 学分</strong>）、体育-基础 1（<strong>0.5 学分</strong>）、信息技术导论（<strong>1 学分</strong>）、思想道德与法治（<strong>2.5 学分</strong>）、程序设计基础与 C 语言程序设计（<strong>4 学分</strong>）、工科数学分析基础 1（<strong>5 学分</strong>）、军训（<strong>2 学分</strong>）</p><p>（大学的课程都有简称，以上课程简称依次为：心理健康，大英 1，健康教育，计算机系统实践、体育、导论课、思修，思政、C 语言、工数 1，高数 1，微积分 1，军训）</p><p>其中计入保研的有：大英 1、计算机系统实践、导论、思政、C 语言、工数 1、军训</p><p>大学的排名是根据均分排的，均分由平均成绩、单项奖学金、竞赛、论文等组成，平均成绩的计算公式是：</p><script type="math/tex; mode=display">\text{假设课程}n\text{的分数为}M_n\text{，学分为}N_n\text{那么你的平均成绩为}\frac{\sum_{i=1}^n{M_i\times N_i}}{\sum_{j=1}^n{N_j}}</script><span id="more"></span><p><code>注：以下评分标准与授课内容仅适用于22级，其他年级若有出入属于正常情况</code></p><h2 id="这些课是学什么的，以及容不容易挂科"><a href="#这些课是学什么的，以及容不容易挂科" class="headerlink" title="这些课是学什么的，以及容不容易挂科"></a>这些课是学什么的，以及容不容易挂科</h2><h4 id="心理健康"><a href="#心理健康" class="headerlink" title="心理健康"></a>心理健康</h4><p>心理健康就是字面意思，会讲大学生如何才能保持一个正常的心理状态，有不正常的心理状态会怎么样。目前没有正常人挂过科</p><h4 id="大英-1"><a href="#大英-1" class="headerlink" title="大英 1"></a>大英 1</h4><p>巨厚的课本，老师会讲里面的课文，讲里面的单词和句子，还有阅读理解。目前没有正常人挂过科</p><h4 id="健康教育"><a href="#健康教育" class="headerlink" title="健康教育"></a>健康教育</h4><p>会讲常见疾病，得病了后如何自我诊断，如何正确就医。虽然课程简单，但是普遍低分且有部分人挂科</p><h4 id="计算机系统实践"><a href="#计算机系统实践" class="headerlink" title="计算机系统实践"></a>计算机系统实践</h4><p>教装机、装系统，上课跟着实操，下课后交报告。目前没有正常人挂过科</p><h4 id="体育"><a href="#体育" class="headerlink" title="体育"></a>体育</h4><p>体育学什么要看你选的什么课，由于我不可能上过所有体育课，无法下结论是否容易挂科</p><h4 id="信息技术导论"><a href="#信息技术导论" class="headerlink" title="信息技术导论"></a>信息技术导论</h4><p>每节课都会请一个巨佬来作报告，讲前沿知识，然后课下写论文交作业。目前没有正常人挂过科</p><h4 id="思想道德与法治"><a href="#思想道德与法治" class="headerlink" title="思想道德与法治"></a>思想道德与法治</h4><p>类似于高中政治课，凭借朴素的爱国情怀就可以及格，你要是挂科了建议出门左转去大连市公安局经济技术开发区分局自首</p><h4 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h4><p>字面意思就学 C 语言，有挂科的，但是不多，不容易挂（==<em>注意，软件学院 C 语言不是在电脑上考试，是纸质试卷手写代码，禁止使用任何电子设备</em>==）</p><h4 id="工科数学分析基础-1"><a href="#工科数学分析基础-1" class="headerlink" title="工科数学分析基础 1"></a>工科数学分析基础 1</h4><p>跟高等数学学的几乎一样，是大一<strong>最容易</strong>挂科的课</p><h4 id="军训"><a href="#军训" class="headerlink" title="军训"></a>军训</h4><p><del>只要别跟教官和导员打起来就不会挂科</del></p><h2 id="计入保研的课怎么学-怎么考试"><a href="#计入保研的课怎么学-怎么考试" class="headerlink" title="计入保研的课怎么学/怎么考试"></a>计入保研的课怎么学/怎么考试</h2><h4 id="大英-1-1"><a href="#大英-1-1" class="headerlink" title="大英 1"></a>大英 1</h4><p>平时会有测试，测试内容以及答案我都放在 NAOSI 的 GitHub 仓库了，为了高分可以提前把题直接背下来。期末考试前会有口语考试，形式是老师面前摆了 15 张卡片，一张卡片有一段话，这些段落都是平时学的课文里的。先把这段话读给老师听，然后老师会根据内容提问问题，问题可能是与课文内容相关的，要求对课文很熟悉，也有可能是开放性问题，比如我当时的问题就是平时会怎么做计划，考察口语能力。期末考试的形式是听力+阅读+单词，单词就是平时测试的，题目都给你们了背下来就行了，听力和阅读都是课外的，跟高中一样</p><h4 id="计算机系统实践-1"><a href="#计算机系统实践-1" class="headerlink" title="计算机系统实践"></a>计算机系统实践</h4><p>好好上课动手多操作一下，不要学计算机的对计算机一窍不通。不要像你们某学长一样，学计算机的不会装系统，不会加固态，甚至不会解压 rar。成绩是根据课下写的报告给的，建议里面图多一点，文字多水一点。（反正老师不管你怎么写的，你可以百度甚至跟历届学长要啊）</p><h4 id="信息技术导论-1"><a href="#信息技术导论-1" class="headerlink" title="信息技术导论"></a>信息技术导论</h4><p>好好水论文字数，好好调整好论文格式就行，给的分数相差不大</p><h4 id="思想道德与法治-1"><a href="#思想道德与法治-1" class="headerlink" title="思想道德与法治"></a>思想道德与法治</h4><p>思政想要考高分还是要多背一背课本的，期末考的题全部是选择题，可以参考 NAOSI 仓库里的题库。不过本人思想觉悟不够高，思政学的并不好，不能给学弟提一些有效的建议</p><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><p>C 语言是软件工程课程的基础，这门课虽然教的极其老套，考试极其死板，但是如果学的不好，也很打击一个软件工程学生的自信心，会自身怀疑是否适合学软件工程这个专业。作为计算机专业的科班生，建议不要仅仅局限于课堂上老师教的内容，要以 C 语言为中心，自学其他内容。比如老师上课不会讲到的文件、算法设计，或者开发方面的。如果仅仅应付考试，多看老师发的 PPT，多看老师上课带着写的程序，学不会的去 b 站自己搜视频，或者查阅相关文档</p><h4 id="工科数学分析基础-1-1"><a href="#工科数学分析基础-1-1" class="headerlink" title="工科数学分析基础 1"></a>工科数学分析基础 1</h4><p>工数 1 是从成绩上讲整个大一最最最最重要的课，与高中数学内容相关性比较高。工数 1 的成绩组成比较复杂，由作业+过程考核+MOOC 平台+期末考试组成，期末考试占 40%，平时占 60%。作业就是老师布置的作业，认真完成按时上交即可。过程考核一共有 3 次，时间听老师安排，一般是每一章讲完后的下周五，一次过程考核计入期末的 10 分，三次共 30 分，非常重要。过程考核内容为选择题+判断题，只考一章的内容，算是小型期中考试。并且过程考核的题目难度要大于期末考试，还会出一些比较恶心的卡概念的题，但考试的题目是从超级大的题库里抽的，题目难度与运气有关。过程考核的时间不是同一个时间，如果你是下午考的，可以利用自己的人际关系问一下上午都考了些什么，脸好的话会遇到原题。MOOC 平台就是线上完成作业，还有同学间互评打分，非常好得分，就是白送你的，但是总有人会忘记写 MOOC，或者写完了忘记互评，这些都会影响分数。期末考试由选择题和大题组成，比高中数学还老套，都是固定题型，想考高分平时就要刷题刷题还是刷题，刷考研题刷竞赛题，期末经常会从历年的考研或竞赛中拿几道改编一下。NAOSI 仓库里有个文件叫“每天起床头件事，先背一遍展开式”，是工数 1 和工数 2（这门课大一下要学）的复习提纲，有需要的自取</p><h4 id="军训-1"><a href="#军训-1" class="headerlink" title="军训"></a>军训</h4><p>不知道怎么得高分</p><h3 id="后记（改编自-20-级某-m-姓学长）"><a href="#后记（改编自-20-级某-m-姓学长）" class="headerlink" title="后记（改编自 20 级某 m 姓学长）"></a>后记（改编自 20 级某 m 姓学长）</h3><p>无论成绩如何，一名软件工程专业的学生都应该在本科阶段掌握以下技能：</p><ul><li>自学</li><li>规范代码格式</li><li>熟练使用 IDE（ VSCode 严格来说不属于 IDE 但依然是宇宙第一）</li><li>阅读 API</li><li>阅读文档</li><li>数据结构与算法</li><li>英文读写</li><li>版本控制工具（Git）和开源仓库（GitHub/Gitee）的使用</li><li>撰写 LaTeX/Markdown 文档</li><li>答辩 （字面意思）</li></ul><h3 id="NAOSI-的-GitHub-仓库"><a href="#NAOSI-的-GitHub-仓库" class="headerlink" title="NAOSI 的 GitHub 仓库"></a>NAOSI 的 GitHub 仓库</h3><p>链接：<a href="https://github.com/NAOSI-DLUT/DLUT_SE_Courses">https://github.com/NAOSI-DLUT/DLUT_SE_Courses</a></p><p>这个仓库是干什么的呢，里面有：</p><ul><li>学长学姐亲传的资料</li><li>你寻找很久的电子参考书</li><li>前人细心雕琢出的大作业</li><li>历年真题</li><li>上完一门课才恍然领悟的技巧</li></ul><p>2023.10.9 补充：<br>上午看见某学长在某个群里发表言论称，考前一个月突击一下，足够考门门 90 拿学习奖学金了，对于这个言论我的意见是，你们可以自己试试看，反正我做不到</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;大一上学期课程简介以及成绩计算相关&quot;&gt;&lt;a href=&quot;#大一上学期课程简介以及成绩计算相关&quot; class=&quot;headerlink&quot; title=&quot;大一上学期课程简介以及成绩计算相关&quot;&gt;&lt;/a&gt;大一上学期课程简介以及成绩计算相关&lt;/h2&gt;&lt;p&gt;软件学院大一上学期的课程有：大学生心理健康教育（&lt;strong&gt;2 学分&lt;/strong&gt;）、大学英语 1（&lt;strong&gt;2 学分&lt;/strong&gt;）、健康教育（&lt;strong&gt;0.5 学分&lt;/strong&gt;）、计算机系统实践（&lt;strong&gt;1 学分&lt;/strong&gt;）、体育-基础 1（&lt;strong&gt;0.5 学分&lt;/strong&gt;）、信息技术导论（&lt;strong&gt;1 学分&lt;/strong&gt;）、思想道德与法治（&lt;strong&gt;2.5 学分&lt;/strong&gt;）、程序设计基础与 C 语言程序设计（&lt;strong&gt;4 学分&lt;/strong&gt;）、工科数学分析基础 1（&lt;strong&gt;5 学分&lt;/strong&gt;）、军训（&lt;strong&gt;2 学分&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;（大学的课程都有简称，以上课程简称依次为：心理健康，大英 1，健康教育，计算机系统实践、体育、导论课、思修，思政、C 语言、工数 1，高数 1，微积分 1，军训）&lt;/p&gt;
&lt;p&gt;其中计入保研的有：大英 1、计算机系统实践、导论、思政、C 语言、工数 1、军训&lt;/p&gt;
&lt;p&gt;大学的排名是根据均分排的，均分由平均成绩、单项奖学金、竞赛、论文等组成，平均成绩的计算公式是：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
&#92;text{假设课程}n&#92;text{的分数为}M_n&#92;text{，学分为}N_n
&#92;text{那么你的平均成绩为}&#92;frac{&#92;sum_{i=1}^n{M_i&#92;times N_i}}{&#92;sum_{j=1}^n{N_j}}&lt;/script&gt;</summary>
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>如何使用 VSCode 编译运行 .c and .cpp 文件</title>
    <link href="https://houyi2333.github.io/2023/09/21/23-05-53/"/>
    <id>https://houyi2333.github.io/2023/09/21/23-05-53/</id>
    <published>2023-09-21T15:05:53.000Z</published>
    <updated>2024-01-27T10:55:14.585Z</updated>
    
    <content type="html"><![CDATA[<p>首先先介绍一下 VSCode 是个什么东西</p><p>VSCode 是一款<strong>轻量级</strong>的<strong>代码编辑器</strong>，可以通过安装各种各样不同<strong>扩展</strong>的方式来实现开发者所需要的功能。</p><p>代码编辑器事实上我们可以看成是一个记事本（没错，就是你按下 Win+R 输入 notepad 回车之后的那个记事本），其最基本的功能是文档编辑。不过之所以将其称为是代码编辑器，是因为它虽然继承自一般的文档编辑器，又具备了一些一般的文档编辑器所不具备的功能。具体来说，例如自动语法高亮，自动补全，甚至是自动代码重构等等。<br>集成开发环境（IDE）是一种用于构建应用程序的软件，可将常用的开发人员工具合并到单个图形用户界面（GUI）中。具体来说，我们只需要简单的点击按钮，可能就可以完成程序的编译、链接、运行、调试等等工作。而这些工作在最初都是需要人手工在命令行中完成的。我们在《程序设计基础与C程序设计》课程中最初使用的 Dev-C++ 便是一个集成开发环境。<br>我们今天要介绍的 VSCode 是一款轻量级的代码编辑器。如果没有各种扩展插件的支持的话，可能我们只能把它称作是大号的记事本，而正是因为社区中各种各样的扩展，VSCode 才得以展现其强大。</p><span id="more"></span><h2 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h2><p>让我们打开 VSCode 官网：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p><p>点击红框里的 <code>Download for Windows</code>，之后浏览器就会自动下载</p><p><img src="/2023/09/21/23-05-53/1.png" alt="1"></p><p><img src="/2023/09/21/23-05-53/2.png" alt="2"></p><p><img src="/2023/09/21/23-05-53/3.png" alt="3">选择我同意此协议</p><p><img src="/2023/09/21/23-05-53/4.png" alt="4">五个复选框全部都打勾</p><p><img src="/2023/09/21/23-05-53/5.png" alt="5">点击安装</p><p>这样我们就能成功打开 VSCode</p><p><img src="/2023/09/21/23-05-53/6.png" alt="6"></p><h2 id="汉化VSCode"><a href="#汉化VSCode" class="headerlink" title="汉化VSCode"></a>汉化VSCode</h2><p>我们可以通过安装中文插件将其汉化</p><p><img src="/2023/09/21/23-05-53/7.png" alt="7"></p><p>重启后我们就得到了中文 VSCode</p><p><img src="/2023/09/21/23-05-53/8.png" alt="8"></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>我们可以先打开终端，尝试输入：<code>g++ --version</code></p><p>如果你的终端返回了  g++ 的版本信息，恭喜，您 C++ 编译器的环境变量配置正确，可以跳过这一章</p><p>如果你的终端返回了：<code>&#39;g++&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件。</code>那么则说明你的终端不知道 <code>g++</code> 是什么命令，接下来需要根据我的教程添加环境变量</p><p>什么是环境变量？</p><p>当你的 Shell 在执行命令时，会尝试在<strong>一系列路径</strong>下搜索同名的可执行文件。这一系列路径我们就称作是环境变量。</p><p>Windows 用户可以在终端中输入 path 来查看当前环境变量（由于我进行过一系列配置，所以其输出结果可能与你的不同）：</p><p><img src="/2023/09/21/23-05-53/image-20240119095335965.png" alt="image-20240119095335965"></p><p>没错，就是这一系列文件夹。回忆我们刚才执行 <code>g++ --version</code> 命令的时候，我们的终端会在这一系列文件夹下为我们寻找叫做 <code>g++</code> 的可执行文件。如果找到了名为 <code>g++</code> 的可执行文件，我们的终端就会将参数传入，将其执行；而如果我们的终端没有找到，那么就会向我们报告“未知命令”。</p><p>我们刚刚已经理解了环境变量的运行逻辑，接下来我们讲解如何进行环境变量的配置。</p><p>对于 Windows 用户，请按下 Windows + S 打开搜索框，在其中输入 <code>path</code>，然后选择”环境变量”，然后选择“系统变量”中的 Path 字段，双击打开后即可配置。</p><p>接下来我们安装MinGW64</p><p>MinGW 的全称是：Minimalist GNU on Windows。</p><p>它实际上是将经典的开源 C 语言编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux平台下的开发工具。</p><p>一句话来概括：MinGW 就是 GCC 的 Windows 版本。这是将你写的 C/C++ 语言的源代码编译成汇编代码，进而链接成可执行文件的工具。之前我们的 Dev-C++ 事实上也集成了这个工具。</p><p>我们下载官方的安装工具（<a href="[MinGW - Minimalist GNU for Windows download | SourceForge.net](https://sourceforge.net/projects/mingw/">链接</a>)），下载完成后打开，无需进行更改，一路点击下一步</p><p>安装完成之后会自动打开MinGW Installation Manager</p><p>我们点击左侧栏中的 Basic Setup ，右侧勾选 mingw32-base 和 mingw32-gcc-g++ 这两个包</p><p><img src="/2023/09/21/23-05-53/image-20240119101136811.png" alt="image-20240119101136811"></p><p>之后点击菜单栏中 Installation 的 Apply Changes</p><p><img src="/2023/09/21/23-05-53/image-20240119101243586.png" alt="image-20240119101243586"></p><p>等待片刻，MinGW即可安装在你的电脑中</p><p>然后，我们需要进行环境变量配置。进入 <code>Mingw64 的安装路径/mingw64/bin/</code>，我们可以看到 <code>gcc</code>，<code>g++</code> 这些我们熟悉的可执行文件。<strong>然后我们需要做的就是将这个文件夹添加至环境变量中。</strong></p><p><img src="/2023/09/21/23-05-53/cb23ba556a7b40a59cd40145b2ac89d4.png" alt="cb23ba556a7b40a59cd40145b2ac89d4"></p><p>然后我们就可以打开终端，输入 <code>g++ --version</code> 验证环境变量是否配置成功。（请注意，在环境变量配置后需要重启终端才能生效）</p><h2 id="插件安装与设置"><a href="#插件安装与设置" class="headerlink" title="插件安装与设置"></a>插件安装与设置</h2><p>这时候我们再装两个插件，一个叫 C/C++，一个叫 Code Runner</p><p><img src="/2023/09/21/23-05-53/6cd952d979ef4a7b994518d2c8c27c56.png" alt="6cd952d979ef4a7b994518d2c8c27c56">                                       <img src="/2023/09/21/23-05-53/2321a98cae5c4830b875837cf552685d.png" alt="2321a98cae5c4830b875837cf552685d"></p><p>然后我们在设置里搜索 code-runner.runInTerminal ，勾选这一项</p><p><img src="/2023/09/21/23-05-53/6f0c3688f1a349eca85d1118e620b2d0.png" alt="6f0c3688f1a349eca85d1118e620b2d0"></p><h2 id="VSCode，启动！"><a href="#VSCode，启动！" class="headerlink" title="VSCode，启动！"></a>VSCode，启动！</h2><p>之后我们点击这个按钮就能在内部终端运行.c 程序了</p><p><img src="/2023/09/21/23-05-53/ac14f764aa4a4bc2a087b9a90821bc9f.png" alt="ac14f764aa4a4bc2a087b9a90821bc9f"></p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>那如果你习惯了用外部终端，可以这样设置一下</p><p>在设置中搜索 code-runner.languageIdToFileExtensionMap ，并在 setting.json 中编辑文件</p><p>在”code-runner.executorMap”这个对象键中加入以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;code-runner.executorMap&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;cpp&quot;</span>: <span class="string">&quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;c&quot;</span>: <span class="string">&quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先先介绍一下 VSCode 是个什么东西&lt;/p&gt;
&lt;p&gt;VSCode 是一款&lt;strong&gt;轻量级&lt;/strong&gt;的&lt;strong&gt;代码编辑器&lt;/strong&gt;，可以通过安装各种各样不同&lt;strong&gt;扩展&lt;/strong&gt;的方式来实现开发者所需要的功能。&lt;/p&gt;
&lt;p&gt;代码编辑器事实上我们可以看成是一个记事本（没错，就是你按下 Win+R 输入 notepad 回车之后的那个记事本），其最基本的功能是文档编辑。不过之所以将其称为是代码编辑器，是因为它虽然继承自一般的文档编辑器，又具备了一些一般的文档编辑器所不具备的功能。具体来说，例如自动语法高亮，自动补全，甚至是自动代码重构等等。&lt;br&gt;集成开发环境（IDE）是一种用于构建应用程序的软件，可将常用的开发人员工具合并到单个图形用户界面（GUI）中。具体来说，我们只需要简单的点击按钮，可能就可以完成程序的编译、链接、运行、调试等等工作。而这些工作在最初都是需要人手工在命令行中完成的。我们在《程序设计基础与C程序设计》课程中最初使用的 Dev-C++ 便是一个集成开发环境。&lt;br&gt;我们今天要介绍的 VSCode 是一款轻量级的代码编辑器。如果没有各种扩展插件的支持的话，可能我们只能把它称作是大号的记事本，而正是因为社区中各种各样的扩展，VSCode 才得以展现其强大。&lt;/p&gt;</summary>
    
    
    
    <category term="VSCode" scheme="https://houyi2333.github.io/categories/VSCode/"/>
    
    
  </entry>
  
</feed>
