<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你不定积分没加C的博客</title>
  
  <subtitle>除了不定积分，还有微分方程通解需要+C</subtitle>
  <link href="https://houyi2333.github.io/atom.xml" rel="self"/>
  
  <link href="https://houyi2333.github.io/"/>
  <updated>2024-06-11T08:55:32.378Z</updated>
  <id>https://houyi2333.github.io/</id>
  
  <author>
    <name>你不定积分没加C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>保皇教程</title>
    <link href="https://houyi2333.github.io/2024/06/11/15-59-58/"/>
    <id>https://houyi2333.github.io/2024/06/11/15-59-58/</id>
    <published>2024-06-11T07:59:58.000Z</published>
    <updated>2024-06-11T08:55:32.378Z</updated>
    
    <content type="html"><![CDATA[<p>由于不同地区的保皇规则存在差异，本教程以我从小玩到大的规则为准，不接受反驳</p><h2 id="游戏介绍"><a href="#游戏介绍" class="headerlink" title="游戏介绍"></a>游戏介绍</h2><p>保皇起源于我国山东青岛，游戏人数最少为 5 人，最多 8 人，由 2 方玩家：<strong>皇帝</strong>（皇帝、侍卫）与<strong>平民</strong>若干人进行对抗，目的是某一方成员<strong>尽可能早出完牌</strong>。 保皇最妙的乐趣在于，侍卫可以隐藏自己的身份，即暗保，当侍卫为暗保时，皇帝和平民都不知道谁是自己人，谁是敌人，于是，大家互相提防、猜忌，又要找出同党来帮助，霎时间流言四起、勾心斗角</p><span id="more"></span><h2 id="基本规则介绍"><a href="#基本规则介绍" class="headerlink" title="基本规则介绍"></a>基本规则介绍</h2><p>保皇使用 4 副扑克牌，但不包含数字 3 到 5，即从 6 开始，一直到 A 、2、小王、大王</p><p>牌的大小比较：大王＞小王＞2＞A＞K＞Q＞J＞10＞9＞8＞7＞6</p><p>游戏中摸到印有彩色“皇帝”标识的大王玩家即为皇帝，摸到印有黑白“皇帝”标识的玩家即为侍卫。皇帝摸到特殊牌后需立即亮出，以供场上所有玩家确认；而侍卫摸到特殊牌后可自由选择亮或不亮，即允许“暗保”，在暗中给皇帝顺牌。如果您同时摸到了这两张特殊牌，您有三种选择：</p><ol><li>暗中打独，即自己一人既当皇帝又当侍卫</li><li>明着打独，明着告诉别人我既当皇帝又当侍卫，<del>起到装逼的作用</del></li><li>把侍卫牌按照逆时针出牌顺序顺给下一位，由下一家担任侍卫（下一家<strong>不允许</strong>拒绝），此时为“明保”状态</li></ol><p>当某一方的所有成员牌全部出完，该阵营获胜</p><h2 id="出牌规则介绍"><a href="#出牌规则介绍" class="headerlink" title="出牌规则介绍"></a>出牌规则介绍</h2><p>保皇不允许像其他扑克游戏一样出顺子，连对，飞机，炸弹等，出牌方式较为单一</p><p>出牌方式1：您可以将数字相同的牌打出，其他人可以用<strong>数量相同</strong>但点数大于你的牌接牌（允许自行决定拆牌，比如您有6张K，可以自己选择拆出来 4 张 K 去打别人的 4 张 J）</p><p>出牌方式2：如果您的牌数量不足，比如别人出了 4 张 K，您只有 3 张 2，您可以选择“挂”一张王，小王或大王均可，用这张王来充当缺的一张 2。同理，如果您缺两张，需要“挂”两张王。此时的 2 我们称为“主牌”，挂的王称为“挂牌”</p><p>出牌方式3：如果别人通过“挂”的方式压倒你的牌，有以下几种情况：</p><ol><li>如果他没有挂大王，仅挂了小王，您可以出“主牌”<strong>点数大于他</strong>且<strong>挂的数量相同或更多的大王</strong>接牌</li><li>如果他没有挂小王，仅挂了大王，您可以出“主牌”<strong>点数大于他</strong>且<strong>挂数量更多的大王</strong>接牌</li><li>如果他既挂了小王，也挂了大王，您可以出“主牌”<strong>点数大于他</strong>且<strong>挂的大王的数量比他小王和大王的数量加起来还要多</strong>接牌</li></ol><p>也就是说，如果别人通过“挂”的方式压倒你的牌，您只能通过“挂”大王来接牌</p><p>不管怎么挂牌，您出牌的总数量总是与上一家出牌的数量相同</p><p>游戏中的 6 <strong>仅允许最后出牌</strong>，如果您的倒数第二次出牌被其他人压死，显然您将<strong><em>再也无法出牌</em></strong>，本局游戏您只能看别人出牌了（乐）。请确保倒数第二次出牌足够大而没有人要的起</p><p>如果您在摸牌后没有 6 ，需要用一张 2 向您的逆时针出牌方向的上一家“购买” 6 。如果上一家也没有 6 ，则向上一家向上上家“购买” 两张6，且您需要用两张 2 向上一家购买一张 6。如果上上家也没有，则需要用三张 2 向上一家购买一张 6，以此类推。如果您没有 2 ，则允许用 A 购买，如果您没有 A ，则允许用 K 购买，以此类推</p><h2 id="进贡"><a href="#进贡" class="headerlink" title="进贡"></a>进贡</h2><p>如果<strong>上一局</strong>游戏皇帝和侍卫为<strong>前三个</strong>出完牌的人，则上一局游戏的平民<strong>每个人</strong>都需要在<strong>下一局</strong>游戏中向<strong>上一局</strong>的皇帝和侍卫<strong>免费</strong>赠送一张 2，其中侍卫根据游戏总人数拿 1 到 2 张，其余归皇帝所有。如果没有 2 则给 A，以此类推。也就是说如果皇帝和侍卫两个人走了一个，其他的平民要尽可能的不让剩的皇帝或侍卫出完牌，否则下一局就要免费送 2 了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于不同地区的保皇规则存在差异，本教程以我从小玩到大的规则为准，不接受反驳&lt;/p&gt;
&lt;h2 id=&quot;游戏介绍&quot;&gt;&lt;a href=&quot;#游戏介绍&quot; class=&quot;headerlink&quot; title=&quot;游戏介绍&quot;&gt;&lt;/a&gt;游戏介绍&lt;/h2&gt;&lt;p&gt;保皇起源于我国山东青岛，游戏人数最少为 5 人，最多 8 人，由 2 方玩家：&lt;strong&gt;皇帝&lt;/strong&gt;（皇帝、侍卫）与&lt;strong&gt;平民&lt;/strong&gt;若干人进行对抗，目的是某一方成员&lt;strong&gt;尽可能早出完牌&lt;/strong&gt;。 保皇最妙的乐趣在于，侍卫可以隐藏自己的身份，即暗保，当侍卫为暗保时，皇帝和平民都不知道谁是自己人，谁是敌人，于是，大家互相提防、猜忌，又要找出同党来帮助，霎时间流言四起、勾心斗角&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>常见随机变量的分布及其数字特征</title>
    <link href="https://houyi2333.github.io/2024/03/31/10-01-25/"/>
    <id>https://houyi2333.github.io/2024/03/31/10-01-25/</id>
    <published>2024-03-31T02:01:25.000Z</published>
    <updated>2024-03-31T03:10:20.241Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><p>下载链接：<a href="./Distributions_of_common_random_variables_and_their_numerical_characteristics.pdf" download>常见随机变量的分布及其数字特征</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;./Distributions_of_common_random_variables_and_their_numerical_characteristics.pdf&quot; download&gt;常见随机变量的分布及其数字特征&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>每天起床头件事，先背一遍展开式</title>
    <link href="https://houyi2333.github.io/2024/02/09/10-43-41/"/>
    <id>https://houyi2333.github.io/2024/02/09/10-43-41/</id>
    <published>2024-02-09T02:43:41.000Z</published>
    <updated>2024-03-16T13:45:06.609Z</updated>
    
    <content type="html"><![CDATA[<p>祝大家新年快乐</p><p>既然除夕不是法定节假日，那就更新一下展开式吧</p><p>下载链接：<a href="./zks.pdf" download>每天起床头件事，先背一遍展开式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;祝大家新年快乐&lt;/p&gt;
&lt;p&gt;既然除夕不是法定节假日，那就更新一下展开式吧&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;./zks.pdf&quot; download&gt;每天起床头件事，先背一遍展开式&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>React 的组件</title>
    <link href="https://houyi2333.github.io/2024/01/29/14-50-06/"/>
    <id>https://houyi2333.github.io/2024/01/29/14-50-06/</id>
    <published>2024-01-29T06:50:06.000Z</published>
    <updated>2024-03-10T10:56:57.761Z</updated>
    
    <content type="html"><![CDATA[<p>React 的核心概念就是组件。组件像是将 UI 拆分得到的独立的可重复使用的小模块，其能够接收属性的传入，并返回描述屏幕上展示内容的 React 元素。React 支持两种组件，一种是类组件，一种是函数组件。但是目前 React 推荐使用函数组件，官方文档也是以函数组件为主，并且函数组件比类组件更加简洁，代码量更少，尤其是在引入 Hooks 之后，避免了类组件中使用生命周期方法的繁琐。因此这个文档也只讲函数组件，不讲类组件</p><span id="more"></span><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>既然组件是独立可复用的，那我们肯定可以编写自己的组件并使用</p><p>在 <code>src</code> 文件夹下新建 <code>Square.tsx</code> 文件，并写入以下代码</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">100</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">100</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> &quot;<span class="attr">red</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p>这样我们就自己编写了一个 100×100 的红色正方形组件，并用 <code>export</code> 关键字导出了这个组件，以便其他组件进行导入</p><p>接下来我们在 <code>App.tsx</code> 中实例化这个正方形组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Square</span> <span class="keyword">from</span> <span class="string">&quot;./Square.tsx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Square</span>&gt;</span><span class="tag">&lt;/<span class="name">Square</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>可以看到，实例化一个组件也是简单的，类似 HTML 的标签语法，下面都是合法的实例化 <code>Square</code> 组件的语句：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Square</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Square</span>&gt;</span><span class="tag">&lt;/<span class="name">Square</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们按下 <code>Ctrl + S</code> 保存，React 就会自动热加载，无需进行刷新即可看到我们页面最新的变化：</p><p><img src="/2024/01/29/14-50-06/image-20240127193617960.png" alt="image-20240127193617960"></p><h2 id="组件的状态"><a href="#组件的状态" class="headerlink" title="组件的状态"></a>组件的状态</h2><p>假设现在我们要完成这样一个任务：把上面的正方形变成能自由修改边长和颜色的</p><p>这里我们就需要通过传入属性的方式对组件进行控制，正如 html 的标签的属性</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Square</span> size=&#123;<span class="number">150</span>&#125; color=<span class="string">&quot;green&quot;</span>&gt;&lt;/<span class="title class_">Square</span>&gt;</span><br></pre></td></tr></table></figure><p>React 允许我们把这些属性以对象的形式捕获，也就是传入的这两个属性参数对象的两个成员：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">props.color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p>按下 <code>Ctrl + S</code> 保存，页面确实变成了我们想要的样子</p><p><img src="/2024/01/29/14-50-06/image-20240128170443924.png" alt="image-20240128170443924"></p><p>但是我们会发现编译器报了一个警告：<code>参数 &quot;props&quot; 隐式具有 &quot;any&quot; 类型，但可以从用法中推断出更好的类型。</code></p><p>根据 TypeScript 哲学，我们应该指定这个参数的类型，这样可以有效避免出现难以探查的 <code>undefined</code> 的问题。指定的方式是 <code>interface</code>，你需要在这个接口之中定义这个组件接受的所有属性。比如说 <code>Square</code> 只需要接受尺寸和颜色：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">props.color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p>这里也可以指定部分属性是可选的（使用 <code>?:</code> ），这样的话实例化组件就没必要传入这一部分属性，通过 <code>props</code> 访问这些属性会得到 <code>undefined</code></p><h2 id="组件的动态"><a href="#组件的动态" class="headerlink" title="组件的动态"></a>组件的动态</h2><p>假设现在我们要完成这样一个任务：正方形如果是红色，单击一下就变成绿色；正方形如果是绿色，单击一下就变成红色</p><p>为了实现动态的效果，需要让组件具有一定的记忆功能，让组件管理自己的状态，这就是 <code>state</code></p><p>我们先考虑这样更改 <code>Square.tsx</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">color</span>: <span class="built_in">string</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                color === &quot;red&quot; ? (color = &quot;green&quot;) : (color = &quot;red&quot;);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p>诶？怎么我怎么点这个正方形颜色都不会变呢</p><p><code>onClick</code> 方法传入的回调函数更新的是局部变量 <code>color</code>，但是<strong>局部变量无法在多次渲染中持续保存</strong>，也就是说，当我们按下 <code>Ctrl + S</code> 保存使得页面重新渲染时，<code>color</code> 又被重新初始化为 <code>&#39;red&#39;</code>，它不会考虑之前对局部变量的任何修改。并且，<strong>局部变量的修改不会触发重新渲染</strong>，React 并不知道需要使用新的数据重新渲染页面。这两个原因导致我们的页面没有达到预期的效果</p><p>要使用新数据更新组件，就需要：<strong>保留渲染前后的数据</strong>、<strong>触发重新渲染</strong>。巧了，<code>useState</code> 这个 Hook 函数提供了这个功能。</p><p>React Hooks 是 React 提供的一类函数的统称，用于在函数组件中添加状态、生命周期和其他 React 特性，而无需编写类组件。使用 Hooks，你可以在函数组件中使用状态和其他 React 特性，使其具有类组件的能力。（如果想要理解什么是生命周期等 React 特性，可以去稍微学一下类组件。正是因为 React 提供了这些 Hook 函数，才使得函数式组件如此的简洁）</p><p>我们先给一下用 <code>useState</code> 修改后的<code>Square.tsx</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                setColor(color === &quot;red&quot; ? &quot;green&quot; : &quot;red&quot;);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p><code>useState</code> 这个函数返回一个包含<strong>两个元素</strong>的数组。数组的第一个元素是<strong>状态变量</strong>（<code>state</code>），而第二个元素是用于<strong>更新状态的函数</strong>（<code>setState</code>）。我们习惯性的将更新状态的函数使用小驼峰命名法命名为 <code>setXxx</code>，其中 <code>xxx</code> 是状态变量名。<code>useState</code> 传入的参数为状态变量的初始值</p><p>更新状态的函数接受一个新的值，当调用 <code>setState</code> 时，会使得状态变量被赋予新的值，同时 React 会重新渲染组件</p><p>对于初学者的建议是，不必深究 <code>useState</code> 是如何实现的，只需要照葫芦画瓢，知道他何时使用和如何使用</p><p>当你调用 <code>useState</code> 时，你是在告诉 React 你想让这个组件记住一些东西。在这个文档的例子中，<code>Square</code> 这个组件需要记住的就是 <code>color</code></p><p>为什么这些函数会被叫做 Hook？因为它们正像钩子一样，允许你不编写<code>componentDidMount</code> 和 <code>componentWillUnmount</code> 等生命周期方法就“钩入” React 的特性。在 React 中，<code>useState</code> 以及任何其他以 <code>use</code> 开头的函数都被称为 Hook。State 只是这些特性中的一个，你之后还会遇到其他 Hook</p><p><strong>==注意==</strong>：<code>setState</code>并不是即时更新的</p><p>这是什么意思呢，我们现在考虑这样一个需求：在正方形中展示出已经点击的次数</p><p>那我们就需要用 <code>useState</code> 来另定义一个状态，这个状态展示了我们的点击次数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> [clickCount, setClickCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                setColor(color === &quot;red&quot; ? &quot;green&quot; : &quot;red&quot;);</span></span><br><span class="line"><span class="language-xml">                setClickCount(clickCount + 1);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            &#123;clickCount&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/29/14-50-06/image-20240128195400009.png" alt="image-20240128195400009"></p><p>需求已经达成了，每次点击显示的数字都会 + 1</p><p>那我们再修改一下代码，我们让 <code>onClick</code> 方法里的 <code>setClickCount</code>方法调用两次：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> [clickCount, setClickCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                setColor(color === &quot;red&quot; ? &quot;green&quot; : &quot;red&quot;);</span></span><br><span class="line"><span class="language-xml">                setClickCount(clickCount + 1);</span></span><br><span class="line"><span class="language-xml">                setClickCount(clickCount + 1);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            &#123;clickCount&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p>那按照我们正常人的思路就会想， <code>setClickCount</code> 方法调用两次，点击一次正方形数字就会 + 2。其实不然，即使你把 <code>setClickCount</code>方法调用一万次也是只 + 1</p><p>以下是这个正方形的点击事件处理函数通知 React 要做的事情：</p><p>1、<code>setColor(color === &#39;red&#39; ? &#39;green&#39; : &#39;red&#39;)</code>：判断 <code>color</code> 的值，React 准备在<strong>下一次渲染时</strong>更改 <code>color</code></p><p>2、<code>setClickCount(clickCount + 1)</code>：<code>clickCount</code> 是 0 所以 <code>setClickCount(0 + 1)</code>，React 准备在<strong>下一次渲染时</strong>将 <code>clickCount</code> 更改为 1</p><p>3、<code>setClickCount(clickCount + 1)</code>：<code>clickCount</code> 是 0 所以 <code>setClickCount(0 + 1)</code>，React 准备在<strong>下一次渲染时</strong>将 <code>clickCount</code> 更改为 1</p><p>尽管调用了两次 <code>setClickCount</code>，但在<strong>这次渲染</strong>的事件处理函数中 <code>clickCount</code> 一直是 0 ，所以 React 会<strong>连续两次</strong>将 <code>clickCount</code> 置 1</p><p>这也就警告我们，不要在 <code>setClickCount</code>方法执行之后立刻去访问 <code>clickCount</code>，很有可能他的值与你预想的不同</p><p>那如果我们就是想连续的调用 <code>setClickCount</code>，就是想让他连续的 + 2，我们可以在 <code>setClickCount</code> 中传入回调函数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> [clickCount, setClickCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                setColor(color === &quot;red&quot; ? &quot;green&quot; : &quot;red&quot;);</span></span><br><span class="line"><span class="language-xml">                setClickCount((o) =&gt; o + 1);</span></span><br><span class="line"><span class="language-xml">                setClickCount((o) =&gt; o + 1);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            &#123;clickCount&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p><code>setState</code> 允许我们传入一个回调函数，在状态更新完成并且组件重新渲染后会被调用。这个回调函数接收一个参数，是当前 <code>State</code> 的值，返回值就是 <code>State</code> 的新的要更新的值</p><p>这里还有另外一个影响因素需要讨论，React 会<strong>等到</strong>事件处理函数中的<strong>所有</strong>代码都运行完毕再处理你的 State 更新，这就是为什么重新渲染只会发生在所有这些 <code>setClickCount()</code> 调用之后的原因</p><p>当你传递一个回调函数给 <code>setState</code> 时，React 会将此函数加入一个队列，以便在事件处理函数中的所有其他代码运行后进行处理。之后在下一次渲染期间，React 会遍历队列并给你更新之后的最终 State。</p><p>以下是这个正方形的点击事件处理函数通知 React 要做的事情：</p><p>1、<code>setColor(color === &#39;red&#39; ? &#39;green&#39; : &#39;red&#39;)</code>：判断 <code>color</code> 的值，React 准备在<strong>下一次渲染时</strong>更改 <code>color</code></p><p>2、<code>setClickCount(o =&gt; o + 1)</code>：<code>o =&gt; o + 1</code> 是一个函数，React 将它加入队列</p><p>3、<code>setClickCount(o =&gt; o + 1)</code>：<code>o =&gt; o + 1</code> 是一个函数，React 将它加入队列</p><p>当你在下次渲染期间调用 <code>useState</code> 时，React 会遍历队列。之前的 <code>clickCount</code> 的值是 0 ，所以这就是 React 作为参数 <code>o</code> 传递给第一个更新函数的值。然后 React 会获取你上一个更新函数的返回值，并将其作为 <code>o</code> 传递给下一个更新函数，以此类推</p><p>React 会保存 2 为最终结果并从 <code>useState</code> 中返回</p><p>如果我们把传入更新值和传入回调函数混着用会怎么样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> [clickCount, setClickCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                setColor(color === &quot;red&quot; ? &quot;green&quot; : &quot;red&quot;);</span></span><br><span class="line"><span class="language-xml">                setClickCount(clickCount + 1);</span></span><br><span class="line"><span class="language-xml">                setClickCount((o) =&gt; o + 1);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            &#123;clickCount&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p>1、<code>setColor(color === &#39;red&#39; ? &#39;green&#39; : &#39;red&#39;)</code>：判断 <code>color</code> 的值，React 准备在<strong>下一次渲染时</strong>更改 <code>color</code></p><p>2、<code>setClickCount(clickCount + 1)</code>：<code>clickCount</code> 是 0 所以 <code>setClickCount(0 + 1)</code>，React 将 _“替换为 1 ”_ 添加到其队列中</p><p>3、<code>setClickCount(o =&gt; o + 1)</code>：<code>o =&gt; o + 1</code> 是一个函数，React 将它加入队列</p><p>React 会保存 2 为最终结果并从 <code>useState</code> 中返回</p><p>这告诉我们，<code>setState(x)</code> 实际上会像 <code>setState(n =&gt; x)</code> 一样运行，只是没有使用 <code>n</code></p><p>如果我们调换 <code>setClickCount(clickCount + 1)</code> 和 <code>setClickCount(o =&gt; o + 1)</code> 的执行顺序：</p><p>1、<code>setColor(color === &#39;red&#39; ? &#39;green&#39; : &#39;red&#39;)</code>：判断 <code>color</code> 的值，React 准备在<strong>下一次渲染时</strong>更改 <code>color</code></p><p>2、<code>setClickCount(o =&gt; o + 1)</code>：<code>o =&gt; o + 1</code> 是一个函数，React 将它加入队列</p><p>3、<code>setClickCount(clickCount + 1)</code>：<code>clickCount</code> 是 0 所以 <code>setClickCount(0 + 1)</code>，React 将 _“替换为 1 ”_ 添加到其队列中</p><p>React 会保存 1 为最终结果并从 <code>useState</code> 中返回</p><h2 id="瀑布数据流与反向数据流"><a href="#瀑布数据流与反向数据流" class="headerlink" title="瀑布数据流与反向数据流"></a>瀑布数据流与反向数据流</h2><p>瀑布数据流指数据的传递只能自上而下，从父组件传递到子组件。比如在“组件的状态”的例子中，<code>App</code> 是父组件，<code>Square</code> 是子组件，父组件通过 <code>props</code> 的方式将 <code>size</code> 和 <code>color</code> 传递给子组件，而子组件不能向父组件传递数据</p><p>但是在开发中我们不可避免的会需要父组件获取到子组件的数据，这就称作反向数据流</p><p>比如我们需要在正方形的下面显示一句话：<code>点击了正方形 clickCount 次</code></p><p>这时候就需要修改 <code>App.tsx</code>，让他获取到子组件中的 <code>clickCount</code>：</p><p>根本获取不了！父组件不能得到子组件的数据！</p><p>解决方案是将 <code>[clickCount, setClickCount]</code> 的声明从子组件提升到父组件，并通过 <code>props</code> 的方式传递下去：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">addCount</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">props.color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;props.addCount&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Square</span> <span class="keyword">from</span> <span class="string">&quot;./Square.tsx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [clickCount, setClickCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Square</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">size</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">color</span>=<span class="string">&#123;</span>&quot;<span class="attr">red</span>&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">addCount</span>=<span class="string">&#123;()</span> =&gt;</span> setClickCount((o) =&gt; o + 1)&#125;</span></span><br><span class="line"><span class="language-xml">            &gt;<span class="tag">&lt;/<span class="name">Square</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击了正方形 &#123;clickCount&#125; 次<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/29/14-50-06/image-20240129173237171.png" alt="image-20240129173237171"></p><p>所谓的子组件控制父组件，并没有违反瀑布数据流，本质是父组件通过 <code>props</code> 将 <code>State</code> 的控制权下放给子组件</p><h2 id="组件的副作用"><a href="#组件的副作用" class="headerlink" title="组件的副作用"></a>组件的副作用</h2><h4 id="什么是副作用"><a href="#什么是副作用" class="headerlink" title="什么是副作用"></a>什么是副作用</h4><p><del>定义：除了主作用以外的作用都叫副作用</del></p><p>但是确实是这样的，函数组件的主作用是渲染组件，所有其他的操作都归类于副作用，比如发送网络请求，从网络中获取数据，监听窗口的大小等。React 通过<code>useEffect</code>这个 Hook 函数来处理组件的副作用</p><h4 id="处理副作用"><a href="#处理副作用" class="headerlink" title="处理副作用"></a>处理副作用</h4><p>现在有这样一个需求：修改页面的标题为 <code>点击了正方形 clickCount 次</code></p><p>修改页面标题不属于渲染，因此需要用 <code>useEffect</code> 实现这个功能</p><p><code>useEffect</code> 接受两个参数，第一个参数是一个回调函数，函数体内编写实现副作用相关代码；第二个参数是可选的，作用是告诉 <code>useEffect</code> 什么时候执行回调函数</p><p><code>useEffect</code> 的返回值是 <code>undefined</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> [clickCount, setClickCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`点击了正方形 <span class="subst">$&#123;clickCount&#125;</span> 次`</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                setColor(color === &quot;red&quot; ? &quot;green&quot; : &quot;red&quot;);</span></span><br><span class="line"><span class="language-xml">                setClickCount(clickCount + 1);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            &#123;clickCount&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/29/14-50-06/image-20240129155849468.png" alt="image-20240129155849468"></p><p>这里我们没有传第二个参数，这表示每一次渲染都会执行副作用</p><p><code>useEffect</code> 的第二个参数是<strong>依赖列表</strong>，是一个数组，例如 <code>[dep1, dep2, dep3]</code>，这表示当依赖列表中变量<strong>发生改变</strong>的时候执行副作用</p><p>如果依赖列表是空列表（<code>[]</code>），那么只在第一次渲染时执行副作用（多用于组件初始化的时候从服务器拉取数据）</p><h4 id="副作用的清除"><a href="#副作用的清除" class="headerlink" title="副作用的清除"></a>副作用的清除</h4><p>我们在 <code>useEffect</code> Hooks 内规定副作用清除逻辑的方法为在回调函数内返回一个函数，在返回的函数内规定副作用清除方式</p><p>比方说我们要让这个正方形定时变色：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareProps</span> &#123;</span><br><span class="line">    <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Square</span> = (<span class="params">props: SquareProps</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">timer</span>: <span class="built_in">any</span>;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> [clickCount, setClickCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">switchColor</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setColor</span>(color === <span class="string">&quot;red&quot;</span> ? <span class="string">&quot;green&quot;</span> : <span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`点击了正方形 <span class="subst">$&#123;clickCount&#125;</span> 次`</span>;</span><br><span class="line">        timer = <span class="built_in">setInterval</span>(switchColor, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">width:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">height:</span> <span class="attr">props.size</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">backgroundColor:</span> <span class="attr">color</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                setClickCount(clickCount + 1);</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            &#123;clickCount&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure><p>为了使内存更安全，我们在使用 <code>setInterval</code> 之后应使用 <code>clearInterval</code> 来停止定时器，防止继续执行周期性的代码</p><p>在上面的例子中，在 <code>useEffect</code> 中第一个参数的回调函数的返回的回调函数，在两种情况下会被调用</p><p>1、如果 <code>useEffect</code> 有依赖列表，那么会在依赖项发生变化时调用</p><p>2、如果 <code>useEffect</code> 没有依赖列表，或者依赖列表为空，则会在这个组件被清理时调用</p><p>编码上建议将副作用拆开，一个副作用对应一个副作用的清除</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，你已经知道了什么是 React Hooks，什么是 React 的组件，如何编写 React 的组件，成功走入了 React 的世界。由于 React 的官方文档目前已经非常完备，本博客将不会继续更新后续 React 的内容，如有学习兴趣请自行阅读 React 官方文档。如果前面所讲的东西你已经掌握，可以从 <a href="https://react.docschina.org/learn/extracting-state-logic-into-a-reducer">迁移状态逻辑至 Reducer 中</a> 开始学习，跳过前面的部分</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;React 的核心概念就是组件。组件像是将 UI 拆分得到的独立的可重复使用的小模块，其能够接收属性的传入，并返回描述屏幕上展示内容的 React 元素。React 支持两种组件，一种是类组件，一种是函数组件。但是目前 React 推荐使用函数组件，官方文档也是以函数组件为主，并且函数组件比类组件更加简洁，代码量更少，尤其是在引入 Hooks 之后，避免了类组件中使用生命周期方法的繁琐。因此这个文档也只讲函数组件，不讲类组件&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>React 开发入门</title>
    <link href="https://houyi2333.github.io/2024/01/22/14-50-06/"/>
    <id>https://houyi2333.github.io/2024/01/22/14-50-06/</id>
    <published>2024-01-22T06:50:06.000Z</published>
    <updated>2024-03-31T13:32:47.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-React-？"><a href="#什么是-React-？" class="headerlink" title="什么是 React ？"></a>什么是 React ？</h2><p>在 2024 年的今天，我们的浏览器仍然采用最基本的 html + CSS + JavaScript 构建页面，但是我们可以很明显的感觉到，编写原生三件套代码是比较复杂的。并且在 Web 项目规模庞大和设备多样性越发丰富的今天，代码的可维护性、开发效率、跨平台开发、性能等因素都会影响到我们对开发工具的选择。因此人们想到了一种方式，可不可以先编写一些简化的、高效率的代码，然后用他们生成 html + CSS + JavaScript 并运行在浏览器上。就像是我们不必编写汇编语言，写 C 语言即可构建可执行文件。就这样， React 诞生了</p><p>维基百科这样定义 React ：React 是一个前端 JavaScript 工具<strong>库</strong>，用于基于 UI 组件构建用户界面</p><p>当前常用的工具（库或框架）不止有 React ，比如 Vue、Angular 等都是常见的构建前端页面的工具</p><p>MDN 这样描述 React ：React 不是一个框架——它的应用甚至不局限于 Web 开发，它可以与其他库一起使用以渲染到特定环境。例如， React Native 可用于构建移动应用程序； React 360 可用于构建虚拟现实应用程序……</p><p>React 是一门令人惊叹的前端技术，其创新性的设计理念和强大的功能使其成为现代 Web 开发的领军者。通过引入虚拟 DOM 、组件化开发和单向数据流等概念， React 不仅提高了应用的性能和可维护性，还让开发者在构建复杂用户界面时拥有更高的灵活性和控制力。 JSX 语法的引入使 UI 代码更加直观和易读，而庞大而活跃的社区生态系统则为开发者提供了丰富的工具和支持。同时， React 的跨平台特性使其在移动开发领域也大放异彩，成为 React Native 的基石。 React 可以被视为一个跨时代的前端开发工具和框架。其引入了许多创新性的概念和技术，对前端开发的方式和效率产生了深远的影响</p><span id="more"></span><h2 id="React-的前世今生"><a href="#React-的前世今生" class="headerlink" title="React 的前世今生"></a>React 的前世今生</h2><h4 id="诞生背景："><a href="#诞生背景：" class="headerlink" title="诞生背景："></a>诞生背景：</h4><p>React 由 Facebook 的工程师 Jordan Walke 于 2011 年创建。最初的目标是解决 Facebook 内部复杂应用的性能问题和开发效率问题</p><h4 id="开源发布："><a href="#开源发布：" class="headerlink" title="开源发布："></a>开源发布：</h4><p>React 在 2013 年 5 月正式开源发布。这一举动使得更多的开发者能够使用和贡献 React ，促进了它的快速发展</p><h4 id="组件化开发："><a href="#组件化开发：" class="headerlink" title="组件化开发："></a>组件化开发：</h4><p>React 采用了<strong>组件化</strong>的开发方式，将 UI 拆分为独立的<strong>组件</strong>，使得代码更加<strong>模块化</strong>、可维护。组件化开发成为 React 的<strong>核心理念</strong>之一，也被其他框架和库广泛采用</p><h4 id="JSX-语法："><a href="#JSX-语法：" class="headerlink" title="JSX 语法："></a>JSX 语法：</h4><p>React 引入了 JSX 语法，允许在 JavaScript 中编写类似 XML 的标记，使 UI 的描述更加直观。 JSX 在编译时会被转换为普通的 JavaScript 代码，使开发者的代码编写更为便捷</p><h4 id="React-Native："><a href="#React-Native：" class="headerlink" title="React Native："></a>React Native：</h4><p>随着移动端应用的兴起， React 的影响力扩展到了<strong>移动开发</strong>领域。 React Native 使开发者能够使用 React 的思想和组件化开发方式来构建原生移动应用，实现了跨平台的目标</p><h4 id="持续更新："><a href="#持续更新：" class="headerlink" title="持续更新："></a>持续更新：</h4><p>React 团队持续进行版本迭代和改进，引入新的特性和优化，以适应前端技术的不断发展和用户需求的变化</p><hr><p>（上面随便看看就行，下面才是正文）</p><h2 id="React-，启动！"><a href="#React-，启动！" class="headerlink" title="React ，启动！"></a>React ，启动！</h2><p>在某个你想要建立该项目的目录下，运行 React 官方提供的脚手架：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create react-app learn-react --template typescript -y</span><br></pre></td></tr></table></figure><p>这行命令表示在当前目录下创建一个新的 react 项目，项目名称为 learn-react ，使用 TypeScript 而不是 JavaScript</p><p>如果安装顺利，使用命令 <code>cd learn-react</code> 进入项目文件夹，输入 <code>npm start</code> 即可编译整个应用，随后应当就可以通过本地 3000 端口访问到 React 的欢迎界面了</p><p><img src="/2024/01/22/14-50-06/image-20240122153740520.png" alt="image-20240122153740520"></p><p>为了更好地阅读本文档，推荐下载简化版 React 框架。其中仅保留了最基础、最必要的代码文件</p><p>下载简化版框架之前，我们希望你已经通过上述步骤成功初始化了一个新的 React 应用并能够在 3000 端口访问到欢迎界面。如果已经确认初始化成功，可以通过 <a href="./src.zip">该链接</a> 下载压缩包，请在解压后使用压缩包内的 <code>src</code> 文件夹替换你的 React 应用的 <code>src</code> 文件夹，并再次使用 <code>npm start</code> 命令运行 React 应用</p><p>如果你现在能够在 3000 端口访问到一个写有 <code>Hello, React!</code> 字样的页面，则已经完成了配置</p><p><img src="/2024/01/22/14-50-06/image-20240122155632922.png" alt="image-20240122155632922"></p><h2 id="虚拟-DOM-技术"><a href="#虚拟-DOM-技术" class="headerlink" title="虚拟 DOM 技术"></a>虚拟 DOM 技术</h2><p>真实 DOM 和虚拟 DOM 是前端开发中的界面渲染相关的两个概念</p><p>真实 DOM 是浏览器创建的文档结构的表示。每个 HTML 元素都是文档对象模型中的一个节点，这些节点以层次结构的形式组织在一起，构成整个页面的结构。操作真实 DOM 可能会引起页面的重绘和重排，因为每次更新都会触发浏览器重新计算布局和绘制页面</p><p>虚拟 DOM 是一个在内存中存在的抽象概念，它是对真实 DOM 的一种映射。通过虚拟 DOM，可以在 JavaScript 中描述页面的结构和状态，而不直接操作真实 DOM。优势是在更新页面时，首先操作虚拟 DOM，然后通过比较虚拟 DOM 和上一次渲染时的虚拟 DOM 的差异（称为 diffing），找出需要更新的部分，最后再将这些变化同步到真实 DOM。可以减少直接操作真实 DOM 带来的性能开销，最终只需要对真实 DOM 进行最小限度的修改，从而提高页面渲染的效率</p><p>React 是一个使用虚拟 DOM 的典型前端库，这种机制可以使我们更专注于应用的状态和逻辑，而不用过于关心底层的 DOM 操作</p><h2 id="React-项目的结构"><a href="#React-项目的结构" class="headerlink" title="React 项目的结构"></a>React 项目的结构</h2><p><img src="/2024/01/22/14-50-06/image-20240122171355674.png" alt="image-20240122171355674"></p><h4 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h4><p>存放项目依赖的第三方库和工具</p><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>包含不需要 webpack 处理的静态资源，如 HTML 文件、网页图标（favicon）等。其中 <code>index.html</code> 是主 HTML 文件，是 React 项目页面加载的入口文件，后面还会再提到它</p><h4 id="src"><a href="#src" class="headerlink" title="src"></a>src</h4><p>包含 React 项目的源码，我们主要编写的就是这个文件夹的内容</p><p>通常里面还会包含 <code>components</code> 、 <code>pages</code> 、 <code>styles</code> 三个文件夹，分别存放了可复用的 React 组件、页面级的 React 组件、样式文件</p><p><code>App.tsx</code> 是我们自定义的一个组件，通过 <code>export default App;</code> 导出，可以被其他文件引入</p><p>接下来重点讲 和 <code>index.tsx</code></p><h5 id="index-tsx"><a href="#index-tsx" class="headerlink" title="index.tsx"></a>index.tsx</h5><p><code>index.tsx</code> 是一个 React 项目中的入口文件，通常用于渲染主应用组件到 HTML 页面：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.tsx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span>);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>解释一下这个文件实现的功能</p><p>使用 <code>import</code> 语句导入 React 和 ReactDOM 库，用于创建和渲染 React 组件</p><p>使用 <code>import</code> 导入主应用组件 <code>App</code></p><p>使用 <code>ReactDOM.createRoot</code> 方法创建一个 <code>root</code> 对象。这个对象代表了 React 渲染的根节点，对应于页面上的容器元素。再通过 <code>document.getElementById(&#39;root&#39;)</code> 方法获取到页面的根元素，之后使用 <code>root.render</code> 方法渲染主应用组件 <code>&lt;App /&gt;</code> 到根节点</p><p>实例化一个组件也是简单的，类似 HTML 语法，只要像 <code>&lt;App /&gt;</code> 一样用尖括号把组件名包裹起来就可以了</p><p>在这个最基本的文件中，<code>&lt;App /&gt;</code> 是一个 React 组件，React 会使用这个组件构建一个虚拟 DOM 树，然后在需要更新时，通过比较新旧虚拟 DOM 树的差异，更新需要更新的部分。但这并不会导致真实 DOM 树的变化，React 会在合适的时机将变化同步到真实 DOM 中，这样可以最小化对真实 DOM 的操作，提高性能。这是 React 中使用虚拟 DOM 的一部分机制</p><p>那我们 id 为 <code>root</code> 的根节点在哪里呢？我们打开 <code>public</code> 中的 <code>index.html</code>：</p><p><img src="/2024/01/22/14-50-06/image-20240122173348696.png" alt="image-20240122173348696"></p><p>诶！根节点就在 <code>index.html</code>。而 React 项目页面加载的入口文件就是 <code>index.html</code> ，这也就解释了为什么页面中可以呈现出我们 <code>return</code> 的 <code>h1</code></p><p><code>index.tsx</code> 的作用就是搭建起传统 HTML 和 React TSX 之间的桥梁，让我们可以自由地使用 TSX 语法编写组件，而将这些组件转换到 HTML 的任务则交给了 React 框架</p><p>那又一个问题出现了： React 项目的 <code>public</code> 文件夹里的 <code>index.html</code> 并没有 link 到 <code>src</code> 下的 <code>index.tsx</code> ，那 <code>index.tsx</code> 是怎么 get 到 <code>root</code> 这个 <code>id</code> 的呢？</p><p>这是因为 React DOM 在运行时会自动查找页面上具有特定 <code>id</code> 的元素，然后将组件渲染到该元素中。具体来说，React DOM 通常会在 <code>index.html</code> 中的 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 元素处渲染应用。这个元素是在 <code>index.html</code> 中静态存在的，而不是通过 JavaScript 动态创建的。React 会将应用渲染到这个预定义的根元素上。说白了就是，这套逻辑已经在 React 的原码里写死了</p><h4 id="gitgnore"><a href="#gitgnore" class="headerlink" title=".gitgnore"></a>.gitgnore</h4><p>指定 Git 版本控制系统忽略特定文件或目录的配置文件，很熟悉了，不多介绍</p><h4 id="prettierrc"><a href="#prettierrc" class="headerlink" title=".prettierrc"></a>.prettierrc</h4><p>用于配置 Prettier 工具的文件（这不是 React 项目之一，这只是 Prettier 插件的配置文件，是我自己添加的）</p><h4 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title=".package-lock.json"></a>.package-lock.json</h4><p><code>npm</code> 在安装包时生成的一个锁定文件，规定了包的安装版本，防止在不同的开发环境上因包的版本不一致出现问题</p><h4 id="package-json"><a href="#package-json" class="headerlink" title=".package.json"></a>.package.json</h4><p>在上一篇《现代前端开发基础》已经讲过</p><h4 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h4><p>React 官方写的 README</p><h2 id="JSX-和-JS-的区别"><a href="#JSX-和-JS-的区别" class="headerlink" title="JSX 和 JS 的区别"></a>JSX 和 JS 的区别</h2><p>JSX 是一种 JavaScript 的语法扩展，也可以说 JSX 是一种方便构建 UI 的语法糖，用于在 JavaScript 代码中描述 UI 结构</p><p>JSX 和原生 JavaScript 的最大差别就是引入了标签语法：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>这类似于 HTML 标签的语法定义了一个对象，其等价于以下表达：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">undefined</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>既然标签可以是变量，那它就可以被返回：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p><code>React.FC</code> 是 React 中的一个泛型类型，用于定义函数组件（Function Components）。在使用 TypeScript 编写 React 组件时，可以使用 <code>React.FC</code> 来明确函数组件的类型<br>我们注意 <code>return &lt;h1&gt;Hello, React!&lt;/h1&gt;;</code> 这行代码，它使得 <code>App</code> 这个函数返回了一个 <code>h1</code> 标签，这种写法我们称为<strong>声明式 UI </strong></p><p>在 JSX 中，每个 JSX 表达式必须被包裹在一个父元素中。比如这样的代码就会报错：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, JSX!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>这是因为 JSX 实际上被转译成 JavaScript 代码，而 JavaScript 中每个表达式只能有一个根节点。</p><p>如果真的要返回两个 <code>h1</code> ，可以考虑将他们放在一个 <code>div</code> 中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, JSX!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>如果你不想使用额外的容器元素，你可以考虑使用 React Fragments。React Fragments（片段）是一种特殊的 React 组件，用于在不添加额外 DOM 元素的情况下包裹多个子元素。Fragments 提供了一种解决“JSX 表达式必须具有一个父元素”这一限制的方式。</p><p>使用 React Fragments 的语法可以是空标签 <code>&lt;&gt;&lt;/&gt;</code> 或 <code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> ，通常使用空标签</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, JSX!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-React-？&quot;&gt;&lt;a href=&quot;#什么是-React-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 React ？&quot;&gt;&lt;/a&gt;什么是 React ？&lt;/h2&gt;&lt;p&gt;在 2024 年的今天，我们的浏览器仍然采用最基本的 html + CSS + JavaScript 构建页面，但是我们可以很明显的感觉到，编写原生三件套代码是比较复杂的。并且在 Web 项目规模庞大和设备多样性越发丰富的今天，代码的可维护性、开发效率、跨平台开发、性能等因素都会影响到我们对开发工具的选择。因此人们想到了一种方式，可不可以先编写一些简化的、高效率的代码，然后用他们生成 html + CSS + JavaScript 并运行在浏览器上。就像是我们不必编写汇编语言，写 C 语言即可构建可执行文件。就这样， React 诞生了&lt;/p&gt;
&lt;p&gt;维基百科这样定义 React ：React 是一个前端 JavaScript 工具&lt;strong&gt;库&lt;/strong&gt;，用于基于 UI 组件构建用户界面&lt;/p&gt;
&lt;p&gt;当前常用的工具（库或框架）不止有 React ，比如 Vue、Angular 等都是常见的构建前端页面的工具&lt;/p&gt;
&lt;p&gt;MDN 这样描述 React ：React 不是一个框架——它的应用甚至不局限于 Web 开发，它可以与其他库一起使用以渲染到特定环境。例如， React Native 可用于构建移动应用程序； React 360 可用于构建虚拟现实应用程序……&lt;/p&gt;
&lt;p&gt;React 是一门令人惊叹的前端技术，其创新性的设计理念和强大的功能使其成为现代 Web 开发的领军者。通过引入虚拟 DOM 、组件化开发和单向数据流等概念， React 不仅提高了应用的性能和可维护性，还让开发者在构建复杂用户界面时拥有更高的灵活性和控制力。 JSX 语法的引入使 UI 代码更加直观和易读，而庞大而活跃的社区生态系统则为开发者提供了丰富的工具和支持。同时， React 的跨平台特性使其在移动开发领域也大放异彩，成为 React Native 的基石。 React 可以被视为一个跨时代的前端开发工具和框架。其引入了许多创新性的概念和技术，对前端开发的方式和效率产生了深远的影响&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>从 JavaScript 到 TypeScript</title>
    <link href="https://houyi2333.github.io/2024/01/21/17-16-23/"/>
    <id>https://houyi2333.github.io/2024/01/21/17-16-23/</id>
    <published>2024-01-21T09:16:23.000Z</published>
    <updated>2024-03-10T10:56:39.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-TypeScript？"><a href="#什么是-TypeScript？" class="headerlink" title="什么是 TypeScript？"></a>什么是 TypeScript？</h2><p>简而言之，TypeScript 是 JavaScript 的超集，它继承了 JavaScript 所有的语法，并且可以编译为纯 JavaScript 。它的目的并不是创造一种全新语言，而是增强 JavaScript 的功能，使其更适合多人合作的企业级项目。</p><p>既然是超集，那么它<strong>超</strong>在哪里呢？</p><p>我们知道， JavaScript 的变量是没有类型的，无论用 <code>var, let, const</code> 哪一个关键字，都无法指定变量的类型，因此我们称 JS 是一个“弱类型”的语言。例如下面的代码，在 JavaScript 中是完全合法的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;34&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = a + str; <span class="comment">// res = &quot;134&quot;</span></span><br></pre></td></tr></table></figure><p>这对我们来说是非常不好的，是反直觉的，正常人的思维应该是，一个数字和字符串怎么可能可以相加呢？这应该报错！</p><p>TypeScript 最大的特点就是引入了类型系统，这样就可以在编译为 JavaScript 代码之前由编译器进行类型检查。在这样的条件下，TypeScript 中的变量在声明的时候就可以指定类型，编译器在将 TypeScript 代码编译为 JavaScript 代码的时候会进行类型检查，若有不符合类型声明的情况则会报错：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = (<span class="attr">name</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">2</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>上面的 <code>fun</code> 函数要求传入一个 <code>string</code> 类型的值，且返回类型为 <code>void</code> 但是我们调用的时候却传入了一个数字 2，这显然是不符合函数参数要求的，因此 TypeScript 编译器会报错</p><p>TypeScript 有着静态类型检查，具有类型系统，可以在开发时捕获许多常见的错误。通过类型检查，可以在编码阶段就发现潜在的问题，减少运行时错误。</p><p>但是，在实际开发中，选择 TypeScript 还是 JavaScript 取决于项目的具体需求和团队的实际情况。首先，对于大型项目、需要长期维护和多人协作的项目，TypeScript 的优势尤为明显。它提供了类型检查和工具支持，可以提高代码的可靠性和团队的效率。而对于小型项目或快速原型开发，JavaScript 可能更适合快速迭代和开发的需求。其次，如果团队已经熟悉 JavaScript 生态系统，并且没有特别需要 TypeScript 的需求，继续使用 JavaScript 也是一个合理的选择。要考虑团队成员的技术水平和学习成本。</p><span id="more"></span><h2 id="TypeScript，启动！"><a href="#TypeScript，启动！" class="headerlink" title="TypeScript，启动！"></a>TypeScript，启动！</h2><p>Node.js 提供了 npm 包管理器，通过<code>npm install -g typescript</code> 即可安装 TypeScript 。通过 <code>tsc</code> 命令即可将 TypeScript 代码编译为 JavaScript 代码。但是它并不支持直接运行编译后的代码，而 <code>ts-node</code> 正好填补了这一空缺，它封装了 TypeScript 的编译过程，使得 TypeScript 代码无需编译成 JavaScript，就能直接运行 TypeScript 代码。由于这是一个教学文档，本文先不使用 <code>ts-node</code></p><p>我们在一个文件夹下启动命令行，输入 <code>npm install -g typescript</code> 安装 TypeScript ，之后输入 <code>tsc --init</code>即可在当前文件夹下初始化 TypeScript 项目。我们会发现当前文件夹下多了一个 <code>tsconfig.json</code> 文件，这是 <code>TypeScript</code> 项目的配置文件，它包含了编译器的配置选项，我们暂时先不动它</p><p>在当前文件夹下新建 <code>index.ts</code> 文件，并编写：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;TypeScript&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;str&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure><p>之后在命令行输入 <code>tsc index.ts</code>，即可编译 <code>index.ts</code> ，同时编译生成的<code>index.js</code> 会被放在同一目录下</p><p>在命令行输入 <code>node index.js</code> ，如果成功输出了 <code>Hello, TypeScript!</code>，证明你的电脑已经成功安装 TypeScript 编译器</p><h2 id="TypeScript-的变量类型"><a href="#TypeScript-的变量类型" class="headerlink" title="TypeScript 的变量类型"></a>TypeScript 的变量类型</h2><p>TypeScript 的变量类型与 C 语言相比简单的多，仅有<strong>布尔类型( _boolean_ )</strong>、<strong>数字类型( _number_ )</strong>、<strong>字符串类型( _string_ )</strong>、<strong>未定义类型( _undefined_ )</strong>、<strong>空类型( _null_ )</strong>、<strong>大数类型( _bigint_ )</strong>、<strong>符号类型( _symbol_ )</strong>、<strong>任意类型( _any_ )</strong>、<strong>never 类型( _never_ )</strong></p><p>其中有必要细讲的是未定义与空，还有任意类型。大数和符号不常用，感兴趣可以自行 Google</p><h4 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h4><p>未定义和空都表示空，但 <code>null</code> 表示这个元素存在，但是是空的； <code>undefined</code> 表示这个元素干脆就不存在。且 <code>undefined</code> 要比 <code>null</code> 常见的多</p><p>这两个类型的相同点是，他们都是只有一个值的数据类型， <code>undefined</code> 的值只有 <code>undefined</code> ， <code>null</code> 的值只有 <code>null</code></p><p>我们先看一张比较经典的图片，该图来自 stackoverflow 的回答</p><p><img src="/2024/01/21/17-16-23/T9M2J.png" alt="T9M2J"></p><ul><li>非零值就像一个装有卫生纸卷的支架，并且管子上仍然有纸巾。</li><li>零值就像一个带有空卫生纸管的支架。</li><li>空值就像一个没有卫生纸管的支架。</li><li>未定义就像连支架都没有</li></ul><p>对于一个未定义的变量，执行 <code>typeof</code> 操作符，那么就会返回 <code>undefined</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> data); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> src); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里我们没有使用 <code>===</code> 来判断，因为对于尚未声明过的变量，我们只能执行使用 typeof 操作符检测其数据类型这个操作，使用其他的操作都会报错</p><p>还有使用对象中不存在的属性，也会返回 <code>undefined</code> ：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">abcdefg</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>从逻辑角度来看， <code>null</code> 值表示一个空对象指针，指示变量未指向任何对象，常在返回类型是对象，但没关联值的地方使用，就像下面：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>); <span class="comment">// container是不存在的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($container); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>如果一个变量已经定义，并且它的值为 <code>null</code> ，那么他的类型就是：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> data); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>你会发现他的类型并不是 <code>null</code>， 而是一个对象。这并不奇怪。从逻辑角度来看， <code>null</code> 值表示一个空对象指针，它代表的其实就是一个空对象。</p><h4 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h4><p>当你不知道该标记什么类型，或者你希望可以写任何类型时，可以谨慎使用 <code>any</code>，编译器将不会尝试对 <code>any</code> 类型的变量做任何的分析。</p><p><code>any</code> 类型是目前 TypeScript 语言之中具有较大争议的一个设计，因为理论上我们可以将所有的变量声明为 <code>any</code> 从而绕过类型检查，这个时候 TypeScript 实际上退化为 JavaScript</p><p>但是考虑到目前 Web 前端项目会引用大量的第三方库，开发者很多时候无法完全把握某些变量的信息，所以 <code>any</code> 类型是必要的。不过我们需要注意其使用，对于能够给定类型的变量则尽量不标记为 <code>any</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">any</span> = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">num = <span class="number">2333</span>; <span class="comment">// OK</span></span><br><span class="line">num = <span class="literal">true</span>; <span class="comment">// OK</span></span><br><span class="line">num = <span class="literal">undefined</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h4 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h4><p>TypeScript 支持一种特殊的类型，即 <code>never</code> 类型。这种类型常被用于标注函数返回值，代表这个函数永远不会终结或者会抛出异常：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> neverEnd = (): <span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种类型的值永远不能被实例化，也即尝试声明和使用 <code>never</code> 类型的值将会总是出现错误，利用个特点，我们可以检测程序是否考虑了所有的情况，这被称为耗尽检查：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">All</span> = <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="comment">// switch 语句用法与 C/C++ 一致</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">value: All</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">typeof</span> value) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;boolean&quot;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">let</span> <span class="attr">exhaustiveCheck</span>: <span class="built_in">never</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据 <code>never</code> 的特点，<code>default</code> 分支的代码执行必然会产生错误，因此如果该 <code>switch</code> 语句未能穷尽 <code>typeof value</code> 的可能取值，使得代码落入 <code>default</code> 分支，导致 <code>never</code> 类型的变量被实例化，进而导致编译器报错</p><p>如果修改类型 <code>All</code> 为 <code>number | string | boolean | undefined</code>，编译器会告诉我们<em>不能将类型“undefined”分配给类型“never”</em>，这就是因为当 <code>value === undefined</code> 时，会尝试将 <code>undefined</code> 赋给 <code>never</code> 类型的变量。 这样，<code>handler</code> 函数就会因为没有耗尽所有可能而报错</p><h2 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h2><p>声明变量时可以在变量后面标注类型，也可以根据初始值自动推断，但如果声明变量时不赋初始值，则必须添加类型标注，否则在使用时会报错（即自动推断该变量为 <code>undefined</code> 的类型，因此不能赋其他值）。</p><h4 id="普通类型标注"><a href="#普通类型标注" class="headerlink" title="普通类型标注"></a>普通类型标注</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Count</span>: <span class="built_in">number</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, TypeScript!&quot;</span>;</span><br></pre></td></tr></table></figure><p>也就是在变量名字后面紧接着跟一个冒号，再加上类型就可以了</p><p>但需要注意的是 TypeScript 允许使用字面量作为类型标注，如：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">one</span>: <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">one = <span class="number">2</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>这里变量 <code>one</code> 的类型被限定为字面量 <code>1</code> 而不是所有的 <code>number</code>，这种标注的作用在下面会展示。</p><h4 id="对象和数组的标注"><a href="#对象和数组的标注" class="headerlink" title="对象和数组的标注"></a>对象和数组的标注</h4><p>对象：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">address</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">address</span>:</span><br><span class="line">        <span class="string">&quot;No. 2, Linggong Road, Ganjingzi District, Dalian City, Liaoning Province&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有元素均相同的数组：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span>[] = [<span class="string">&quot;Embedded&quot;</span>, <span class="string">&quot;Web&quot;</span>, <span class="string">&quot;Media&quot;</span>];</span><br><span class="line"></span><br><span class="line">learning_direction = <span class="string">&quot;Web&quot;</span>; <span class="comment">// Error! 不能将类型“string”分配给类型“string[]”</span></span><br><span class="line">learning_direction = [<span class="string">&quot;Web&quot;</span>]; <span class="comment">// Success</span></span><br></pre></td></tr></table></figure><p>固定长度和类型的数组：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: [<span class="built_in">number</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="literal">false</span>];</span><br></pre></td></tr></table></figure><h4 id="函数的标注"><a href="#函数的标注" class="headerlink" title="函数的标注"></a>函数的标注</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，函数名为 <code>sum</code>， 两个参数类型均为 <code>number</code> ，返回值也为 <code>number</code></p><p>这里要注意的是，编译器会尝试推断函数返回值，但<strong>不会尝试从函数实现中</strong>推断参数类型，因此参数列表的类型标注是必不可少的。</p><p>也可以按照声明变量的方式：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>sum</code> 作为一个变量，它的类型并非前文所提过的原始值，因此也是一个对象，它的构造函数是 <code>function</code></p><p>如果使用箭头函数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法的结果相同</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt; x + y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然我们函数参数有了类型的限制，但是实际上 TypeScript 在运行时并不会检查你的调用是否符合参数列表（尽管在编译器会尝试进行静态检查，但是如果你使用 <code>any</code> 或其他一些方法传入其他类型参数，仍然会继续运行）</p><p>在 JavaScript 中，甚至不会检查你函数调用的时候传入参数的个数，但是 TypeScript 会阻止传入个数错误的参数</p><p>在 TypeScript 中可以通过将参数标为可选或提供默认值来允许不同长度的传入参数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">1</span>, z?: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// y的默认值是1，z为可选参数</span></span><br><span class="line">    <span class="keyword">return</span> x + y + (z ?? <span class="number">0</span>); <span class="comment">// 这里 y 不可能为空值，但 z 可能。如果函数调用没有给出z，那么z默认是0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>)); <span class="comment">// =&gt; 1 + 1 + (undefined ?? 0) = 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// =&gt; 1 + 0 + (undefined ?? 0) = 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// =&gt; 1 + 2 + (3 ?? 0) = 6</span></span><br></pre></td></tr></table></figure><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>可以使用 <code>type</code> 关键词定义类型别名，在需要实现复杂的类型时非常有用：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> numberOne = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">one</span>: numberOne = <span class="number">1</span>;</span><br><span class="line">one = <span class="number">2</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><h4 id="联合类型和类型收窄"><a href="#联合类型和类型收窄" class="headerlink" title="联合类型和类型收窄"></a>联合类型和类型收窄</h4><p>TypeScript 可以将变量的类型声明为若干个类型之一，这称为联合类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">union</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">7</span>;</span><br><span class="line">union = <span class="string">&quot;Genshin Impact&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">union = <span class="number">8</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>上面的 <code>union</code> 变量，既可以是 <code>number</code> 类型，也可以是 <code>string</code> 类型</p><p>联合类型最常用的地方是标注函数参数，这样就允许了函数接受多种类型的参数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addHello = (<span class="attr">x</span>: <span class="built_in">number</span> | <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span> + x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addHello</span>(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">addHello</span>(<span class="string">&quot;Dalian&quot;</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>上文提到字面量可以作为类型标注，那么使用联合类型，就可以实现枚举行为：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> oddNumber = <span class="number">1</span> | <span class="number">3</span> | <span class="number">5</span> | <span class="number">7</span> | <span class="number">9</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: oddNumber = <span class="number">5</span>; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: oddNumber = <span class="number">2</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>_这就是上面提到的复杂类型之一_</p><p>对于“所有元素均相同的数组”的实例代码出现的错误，如果更改为下面的代码：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] = [<span class="string">&quot;Embedded&quot;</span>, <span class="string">&quot;Web&quot;</span>, <span class="string">&quot;Media&quot;</span>];</span><br><span class="line"></span><br><span class="line">learning_direction = <span class="string">&quot;Web&quot;</span>; <span class="comment">// Success</span></span><br><span class="line">learning_direction = [<span class="string">&quot;Web&quot;</span>]; <span class="comment">// Success</span></span><br></pre></td></tr></table></figure><p>这里我们声明 <code>learning_direction</code> 可能有两种类型，即 <code>string</code> 和 <code>string[]</code>，所以我们可以将其任意赋值为其中的一种，但这就导致我们在使用这一值时，不能精确判断上面包含的方法，例如我们尝试执行：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learning_direction.<span class="title function_">match</span>(<span class="regexp">/react/</span>); <span class="comment">// Error! 类型“string[]”上不存在属性“match”</span></span><br></pre></td></tr></table></figure><p>这里编译器会报错，但如果我们的代码足以让编译器推断出来变量类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> learning_direction === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(learning_direcion.<span class="title function_">match</span>(<span class="regexp">/react/</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够进入 <code>if</code> 判断的第一个大括号的语句，那 <code>learning_direction</code> 就一定是 <code>string</code> 类型，编译器自己就能够明白，这么做是安全的，允许调用相应的方法，这种行为被称为<strong>类型收窄</strong></p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>这种语法只用在一种情况：你认为你比编译器还懂这个变量的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] = [<span class="string">&quot;Embedded&quot;</span>, <span class="string">&quot;Web&quot;</span>, <span class="string">&quot;Media&quot;</span>];</span><br><span class="line"></span><br><span class="line">(learning_direction <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">string</span>).<span class="title function_">match</span>(<span class="regexp">/react/</span>);</span><br></pre></td></tr></table></figure><p>我们这里使用 <code>as</code> 关键字，告诉编译器 <code>learning_direction</code> 这个变量一定为 <code>string</code> 类型，不可能是 <code>string[]</code> 类型，这个时候编译器就会听你的，把他它当作 <code>string</code> 类型处理</p><p>但你不能断言一个变量为明显冲突的类型</p><p>比如上述代码，如果是 <code>(learning_direction as string).match  (/react/);</code> ，那么就会报错，所以我们要先断言为 <code>unknown</code> 再断言为其他类型</p><h2 id="TypeScript-的复杂类型"><a href="#TypeScript-的复杂类型" class="headerlink" title="TypeScript 的复杂类型"></a>TypeScript 的复杂类型</h2><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>这类似于 C++的模板</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数泛型</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是函数泛型</span></span><br><span class="line"><span class="keyword">const</span> identity = &lt;<span class="title class_">Type</span>,&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="function"><span class="params">Type</span> =&gt;</span> arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;<span class="title class_">NumType</span>&gt; &#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: <span class="title class_">NumType</span>;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象泛型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Request</span>&lt;<span class="title class_">ReqBody</span>, <span class="title class_">ResBody</span>&gt; &#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="title class_">ReqBody</span>;</span><br><span class="line">    <span class="attr">response</span>: <span class="title class_">ResBody</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别名泛型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MaybeArray</span>&lt;<span class="title class_">Value</span>&gt; = <span class="title class_">Value</span> | <span class="title class_">Value</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">//它们的实例化</span></span><br><span class="line">identity&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">req</span>: <span class="title class_">Request</span>&lt;&#123; <span class="attr">action</span>: <span class="built_in">string</span> &#125;, &#123; <span class="attr">result</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">    <span class="attr">request</span>: &#123;</span><br><span class="line">        <span class="attr">action</span>: <span class="string">&quot;update system&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">response</span>: &#123;</span><br><span class="line">        <span class="attr">result</span>: <span class="string">&quot;succeeded&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">nums</span>: <span class="title class_">MaybeArray</span>&lt;<span class="built_in">number</span>&gt; = <span class="number">0</span>;</span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>可以为泛型添加限制和默认值，也可以由编译器推断泛型类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span> = <span class="built_in">number</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identity</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">data</span>: <span class="built_in">string</span> &#125;&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identity</span>(&#123; <span class="attr">data</span>: <span class="string">&quot;str&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="typeof-和-keyof-关键字"><a href="#typeof-和-keyof-关键字" class="headerlink" title="typeof 和 keyof 关键字"></a>typeof 和 keyof 关键字</h4><p><code>typeof</code> 除了可以作为运算符获取变量类型以外，用作类型标注时，可以获取变量的具体类型（而非作为运算符时的有限种类）：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someObj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg: <span class="keyword">typeof</span> someObj</span>) &#123;</span><br><span class="line">    <span class="comment">// arg: &#123; foo: number; bar: string &#125;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>keyof</code> 可以获取类型的键的类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg: keyof <span class="keyword">typeof</span> Obj</span>) &#123;</span><br><span class="line">    <span class="comment">// arg: &#x27;foo&#x27; | &#x27;bar&#x27;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>与 C 语言的三目运算符语法相同，但是在 TypeScript 中与泛型结合会更有用</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">any</span> &#125; ? T[<span class="string">&quot;message&quot;</span>] : <span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;; <span class="comment">// EmailMessageContents = string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Dog</span>&gt;; <span class="comment">// DogMessageContents = unknown</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-TypeScript？&quot;&gt;&lt;a href=&quot;#什么是-TypeScript？&quot; class=&quot;headerlink&quot; title=&quot;什么是 TypeScript？&quot;&gt;&lt;/a&gt;什么是 TypeScript？&lt;/h2&gt;&lt;p&gt;简而言之，TypeScript 是 JavaScript 的超集，它继承了 JavaScript 所有的语法，并且可以编译为纯 JavaScript 。它的目的并不是创造一种全新语言，而是增强 JavaScript 的功能，使其更适合多人合作的企业级项目。&lt;/p&gt;
&lt;p&gt;既然是超集，那么它&lt;strong&gt;超&lt;/strong&gt;在哪里呢？&lt;/p&gt;
&lt;p&gt;我们知道， JavaScript 的变量是没有类型的，无论用 &lt;code&gt;var, let, const&lt;/code&gt; 哪一个关键字，都无法指定变量的类型，因此我们称 JS 是一个“弱类型”的语言。例如下面的代码，在 JavaScript 中是完全合法的&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&amp;quot;34&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; res = a + str; &lt;span class=&quot;comment&quot;&gt;// res = &amp;quot;134&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这对我们来说是非常不好的，是反直觉的，正常人的思维应该是，一个数字和字符串怎么可能可以相加呢？这应该报错！&lt;/p&gt;
&lt;p&gt;TypeScript 最大的特点就是引入了类型系统，这样就可以在编译为 JavaScript 代码之前由编译器进行类型检查。在这样的条件下，TypeScript 中的变量在声明的时候就可以指定类型，编译器在将 TypeScript 代码编译为 JavaScript 代码的时候会进行类型检查，若有不符合类型声明的情况则会报错：&lt;/p&gt;
&lt;figure class=&quot;highlight tsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fun = (&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;): &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;void&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, &amp;quot;&lt;/span&gt; + name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title function_&quot;&gt;fun&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// Error!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的 &lt;code&gt;fun&lt;/code&gt; 函数要求传入一个 &lt;code&gt;string&lt;/code&gt; 类型的值，且返回类型为 &lt;code&gt;void&lt;/code&gt; 但是我们调用的时候却传入了一个数字 2，这显然是不符合函数参数要求的，因此 TypeScript 编译器会报错&lt;/p&gt;
&lt;p&gt;TypeScript 有着静态类型检查，具有类型系统，可以在开发时捕获许多常见的错误。通过类型检查，可以在编码阶段就发现潜在的问题，减少运行时错误。&lt;/p&gt;
&lt;p&gt;但是，在实际开发中，选择 TypeScript 还是 JavaScript 取决于项目的具体需求和团队的实际情况。首先，对于大型项目、需要长期维护和多人协作的项目，TypeScript 的优势尤为明显。它提供了类型检查和工具支持，可以提高代码的可靠性和团队的效率。而对于小型项目或快速原型开发，JavaScript 可能更适合快速迭代和开发的需求。其次，如果团队已经熟悉 JavaScript 生态系统，并且没有特别需要 TypeScript 的需求，继续使用 JavaScript 也是一个合理的选择。要考虑团队成员的技术水平和学习成本。&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>现代前端开发基础</title>
    <link href="https://houyi2333.github.io/2024/01/20/12-33-21/"/>
    <id>https://houyi2333.github.io/2024/01/20/12-33-21/</id>
    <published>2024-01-20T04:33:21.000Z</published>
    <updated>2024-03-14T12:50:38.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="库和框架"><a href="#库和框架" class="headerlink" title="库和框架"></a>库和框架</h2><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>库是一系列预先定义好的数据结构和函数或类的集合，程序员可以通过调用这些代码实现功能。简单来说就是库为我们提供了很多封装好的函数，看起来比较零散，但使用起来更灵活，只用取里面我们需要的某部分，再自己实现项目中其他部分得功能</p><p>库就类似于 C 语言中的头文件，比如 <code>&lt;stdio.h&gt;</code> 头文件提供了一系列常用的功能：<code>printf()</code>、<code>scanf()</code>、<code>gets()</code>、<code>fopen()</code> 等</p><p>在前端开发中，使用库可以简化开发流程，提高开发效率。例如，jQuery 提供了简化 DOM 操作的语法，减少了编写繁琐代码的需要。React 通过虚拟 DOM 和声明式 UI ，便于快速构建用户界面</p><p>如果需要在网页中使用 JavaScript 库，可以去网上下载库文件，放在网页的同一目录下，再到<code>script</code>标签中引入。或者不下载通过通过链接在<code>&lt;script&gt;</code>标签中引用该库即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/3.4.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在代码中通过 <code>require</code> 或者 <code>import</code> 中引入库。在现代的前端开发中，通常推荐使用 <code>import</code> 来进行模块导入，特别是在使用现代 JavaScript 特性的项目中。这主要与现代 JavaScript 的发展趋势和语言特性有关</p><p><code>import</code> 是 ES6 新引入的关键字，支持按需导入，而不需要导入整个模块。同时<code>import</code> 的语法也比 <code>require</code> 更直观清晰，更符合现代变成风格</p><p>随着 JavaScript 生态的发展，越来越多的库和工具采用了 ES6 模块系统，使用 <code>import</code> 能够更好地与这些现代化的工具和库进行集成。</p><span id="more"></span><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>框架是提供如何构建应用程序的意见的库，是一整套的工具，所有东西已经准备齐全了，可以按照它的规定就可以很简单的完成一些事情，但我们不能去改变它，只能按照要求使用，并且其他人拿到这套工具也是一样的，如 Vue、Angular 等等。</p><p>注意是一套而不是单个，比如 React 就是一个库，它本身只是一个前端渲染的库，纯粹地写 UI 组件，没有什么异步处理机制、模块化等，但是当它结合 Redux 和 React-router 的时候，就是一个框架了。</p><p>框架和库的联系紧密，都是为了提高我们的开发效率而存在，库的使用上会简单一些，更加灵活，但功能不全。而框架的功能很全面，但需要我们按规定去使用。也就是说库是一种工具，我提供了，你可以不用，即使你用了，也没影响你自己的代码结构，控制权在使用者手中。框架则是面向一个领域，提供了一套解决方案</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>库是一组已经实现的代码集合，提供了特定功能的函数和方法，开发者可以根据需要选择性地使用。库不控制应用程序的整体架构，而是为开发者提供了可调用的工具，以便在应用程序中实现特定功能</p><p>框架是一种提供了一整套解决方案的软件结构，它规定了整个应用程序的架构，定义了组织代码的方式，并提供了一系列工具和库，以便开发者可以在框架的基础上构建应用。框架通常有一个完整的生命周期，控制着应用程序的流程，开发者需要按照框架的规则来编写代码。</p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h4 id="什么是-Node-js"><a href="#什么是-Node-js" class="headerlink" title="什么是 Node.js"></a>什么是 Node.js</h4><p>JavaScript 是一个脚本语言，最初用来处理网页中的一些动态功能和一些用户行为。它一般运行于浏览器</p><p>但是这门语言后续不断更新，越来越多的人开始使用 JavaScript 。为了把它迁移到了服务端，但服务端上又不能跑浏览器，那我们就需要一种新的运行环境。就这样，这个基于 Chrome V8 引擎的 JavaScript 运行时 Node.js 诞生了</p><h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><p>打开 Node.js 的官网<a href="http://www.nodejs.org">链接</a></p><p>单击左侧的 LTS 版本进行下载</p><p><img src="/2024/01/20/12-33-21/image-20240123155049028.png" alt="image-20240123155049028"></p><p>安装过程没什么好说的，一路下一步</p><p><img src="/2024/01/20/12-33-21/image-20240123155413105.png" alt="image-20240123155413105"></p><p>之后我们就可以在终端中执行 <code>node</code>命令编译运行 <code>.js</code> 文件</p><p><img src="/2024/01/20/12-33-21/image-20240123155752568.png" alt="image-20240123155752568"></p><h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><p>在计算机编程中，模块是指一个相对独立的程序文件或代码库，通常包含一组相关的函数、变量、类或其他可重用的代码构件，每个模块在内部执行某个功能。并向外部公开一定的接口以供其他模块使用。在编程语言中，通常有一些标准库或第三方库，这些库都是由多个模块组成的，可以在程序中被引用和使用。模块化主要是为了帮助程序员组织和管理大型代码库，可以将大型的程序有逻辑地拆分成一个个相对较小的部分，实现代码复用，让程序设计更加灵活，使其更易于维护和扩展。这是优点之一。并且还可以避免变量名和函数名命名冲突的问题以及解决不同模块之间的依赖关系。</p><p>比如，我要写一个 Wordle 小游戏，普通代码编写就把所有代码像画布渲染，键盘的输入，逻辑判断等都写到一个 HTML 文件里，如果使用模块化概念，我们可以简单分块，分成主文件，键盘输入，逻辑判断以及读取 json 等多个模块，然后在各个文件里实现相应的逻辑，这样假如你发现 json 的读取有问题，你就可以直接去找读 json 那个文件有没有问题，这样会让代码的后续维护更简单，目的更明确。</p><p><code>import</code> 和 <code>export</code> 是 ES6 引入的模块系统的关键字，用于在 JavaScript 中进行模块化编程。模块化使得代码更结构化、可维护，并允许开发者将代码分割为小的可重用部分</p><h4 id="export-的使用："><a href="#export-的使用：" class="headerlink" title="export 的使用："></a><code>export</code> 的使用：</h4><p><code>export</code> 用于将变量、函数、类或其他声明导出为模块的公共接口，以便其他模块可以使用。有三种常见的 <code>export</code> 的方式</p><h5 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h5><p>可以通过 <code>export</code> 关键字单独导出多个成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h5><p>通过 <code>export default</code> 关键字导出一个默认成员，每个模块只能有<strong>一个</strong>默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myVariable;</span><br></pre></td></tr></table></figure><h4 id="import-的使用："><a href="#import-的使用：" class="headerlink" title="import 的使用："></a><code>import</code> 的使用：</h4><p><code>import</code> 用于在一个模块中引入其他模块导出的成员，以便在当前模块中使用。有三种常见的 <code>import</code> 的方式：</p><h5 id="命名导入"><a href="#命名导入" class="headerlink" title="命名导入"></a>命名导入</h5><p>导入其他模块中的命名导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myVariable, myFunction &#125; <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h5><p>导入其他模块中的默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> myVariable <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="导入所有"><a href="#导入所有" class="headerlink" title="导入所有"></a>导入所有</h5><p>导入其他模块的所有导出，形成一个命名空间对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myVariable = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> internalVariable = <span class="string">&quot;internal&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> internalVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; myVariable, myFunction &#125; <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myVariable); <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">myFunction</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> internalVariable <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(internalVariable); <span class="comment">// &#x27;internal&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">myVariable</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>JavaScript 包是一种封装了代码、资源的组织形式，能够方便共享、安装和管理代码。这些包可以包含 JavaScript 库、框架、工具或应用程序等。而 <code>npm</code> 就是管理这些包的工具（当然除了 <code>npm</code> 也有其他工具，比如 <code>yarn</code>、<code>yum</code>等），专门用于在服务器端和命令行工具中管理 JavaScript 包</p><p>为什么我们需要包管理工具呢？我们一次性把包都下载到电脑里，像 C 语言的头文件一样，需要用什么拿什么不就好了吗？首先，JavaScript 的包多达 90 万个，将所有这些包完全下载到本地会占用大量存储空间。这对于开发者的计算机来说可能是不切实际的，特别是在多个项目中共享相同的依赖项时。其次，软件包和库经常会更新，手动下载所有包可能导致更新不及时，使得项目失去了最新的功能和安全性修复。最后，有的项目需要使用某个包特定的版本，使用其他版本会导致项目无法运行或出现其他 bug，而包管理工具允许开发者指定项目所使用的依赖项的特定版本，以确保项目的稳定性和一致性。手动下载所有包可能会导致版本冲突和不同环境之间的不一致。因此我们需要使用包管理工具</p><p><code>npm</code> 是随同 Node.js 安装的包管理工具，安装好 node 之后就会默认安装好 <code>npm</code> 了</p><p>我们可以在命令行中输入 <code>npm -v</code> 判断是否安装了 <code>npm</code></p><p><img src="/2024/01/20/12-33-21/image-20240123213514850.png" alt="image-20240123213514850"></p><p>如果成功获取到了版本号，说明 <code>npm</code> 已经成功的安装在您的电脑中了</p><h5 id="npm-的常见命令"><a href="#npm-的常见命令" class="headerlink" title="npm 的常见命令"></a><code>npm</code> 的常见命令</h5><p><code>npm install &lt;Module Name&gt;</code> 使用 <code>npm</code> 命令本地安装模块</p><p><code>npm install -g &lt;Module Name&gt;</code> 全局安装</p><p>两个的区别就是本地安装将安装包放在当前文件夹的 <code>node_modules</code> （如果没有则会自动生成）文件夹下，通过 <code>import</code> 来引入本地安装的包；全局安装包则通常放在 <code>node</code> 的安装目录下，可以直接在命令行里使用</p><p><code>npm uninstall &lt;Name&gt;</code> 卸载模块</p><p><code>npm install -g npm@&lt;版本号&gt;</code> 更新 <code>npm</code></p><p><code>npm publish</code> 将自己的代码发布到 <code>npm</code> 上的全球开源库中</p><h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h5><p><code>package.json</code> 是 Node.js 项目中的一个重要文件，它用于存储项目的配置信息。包含了项目的元数据（metadata），如项目名称、版本、作者、依赖库等信息。通过描述项目上下文、所需依赖和开发脚本，使项目具备可重复性和可移植性</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;learn_react&quot;</span><span class="punctuation">,</span> <span class="comment">// 项目的名称</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.1.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 项目的版本号</span></span><br><span class="line">    <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 用于指示是否将该项目发布到公共的包注册表的标志</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 项目运行时所依赖的第三方包</span></span><br><span class="line">        <span class="attr">&quot;@testing-library/jest-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.14.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@testing-library/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^13.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@testing-library/user-event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^13.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@types/jest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^27.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@types/node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^16.7.13&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@types/react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^18.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;react-scripts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;typescript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.4.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;web-vitals&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.1.0&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 定义一组自定义的命令脚本</span></span><br><span class="line">        <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts start&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts build&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts test&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 用于指定项目所支持的目标浏览器范围的配置文件，通常用于前端开发</span></span><br><span class="line">        <span class="attr">&quot;production&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;&gt;0.2%&quot;</span><span class="punctuation">,</span> <span class="comment">// 支持全球使用率超过0.2%的浏览器</span></span><br><span class="line">            <span class="string">&quot;not dead&quot;</span><span class="punctuation">,</span> <span class="comment">// 排除已经被官方宣布为不再更新的浏览器</span></span><br><span class="line">            <span class="string">&quot;not op_mini all&quot;</span> <span class="comment">// 用于排除 Opera Mini 浏览器，Opera Mini 具有一些独特的行为或限制，需要在项目中进行特殊处理</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;development&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;last 1 chrome version&quot;</span><span class="punctuation">,</span> <span class="comment">// 支持每个浏览器的最后一个版本</span></span><br><span class="line">            <span class="string">&quot;last 1 firefox version&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果项目有 <code>package.json</code> 文件，则通过命令 <code>npm install</code> 可以根据 <code>&quot;dependencies&quot;</code> 自动在 <code>node_modules</code> 文件夹中安装项目所需的所有包</p><p>注：上述 <code>package.json</code> 的注释是粘贴到 md 后再加的，目的是讲解键值对的意义，而 json 文件中是不允许添加注释的：</p><p><img src="/2024/01/20/12-33-21/image-20240310183237979.png" alt="image-20240310183237979"></p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>打包是指将多个模块（ JavaScript、CSS、图片等）打包成为一个文件，这有助于代码管理、发布和使用。在前端开发中，通常需要使用打包工具将代码打包成浏览器可识别的格式，并优化加载速度和性能。</p><p>为什么前端需要打包？以前的前端开发存在三个大问题：没有模块化、第三方包的引入繁琐困难、代码以明文形式展示出来</p><p>我们利用打包工具就可以实现：支持模块化、自动打包第三方包、代码混淆，使得其他人无法阅读</p><p>下面介绍两个常使用的与打包有关的工具</p><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>Babel 是一个 JavaScript 编译器，它能够将 ECMAScript 2015+ 的新特性转换为向后兼容的 JavaScript 代码，例如将 ES6 的箭头函数转换为普通函数、将模板字符串转换为常规字符串等等，使得我们可以在现代浏览器中使用最新的 JavaScript 特性，从而解决浏览器兼容性问题</p><p>执行 <code>npm install -g babel-cli</code> 安装 Babel</p><p>在项目根目录创建 <code>.babelrc</code> 文件，这是 Babel 的配置文件，并编写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;es2015&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>执行 <code>npm install babel-preset-es2015</code> 安装转码器，就是从源码转到老版本的代码中间的语法映射表</p><p>在根目录创建 <code>src</code> 文件夹，新建 <code>index.js</code> 并编写如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">[a, b, c] = [b, c, a + <span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);</span><br></pre></td></tr></table></figure><p>这里用到了 ES6 的新特性解构赋值，执行 <code>babel src -d dist</code> Babel 就能够将它转换为旧的 ES2015 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./dist/index.js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> _ref = [b, c, a + <span class="number">1</span>];</span><br><span class="line">a = _ref[<span class="number">0</span>];</span><br><span class="line">b = _ref[<span class="number">1</span>];</span><br><span class="line">c = _ref[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c);</span><br></pre></td></tr></table></figure><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>Webpack 是一个模块打包工具，它可以将多个模块打包成一个或多个 JavaScript 文件，而这些 JavaScript 文件可以被浏览器正确加载执行。Webpack 可以处理各种类型的资源文件，如 JS、CSS、图片等，并提供了各种插件和 loader 用于对不同类型的资源进行处理和优化，同时还支持热更新功能，方便开发人员进行调试和开发</p><p>Webpack 会隐藏源码的细节，把多个 JavaScript 合并成一个 JavaScript，提高浏览器的访问速度，使源码更加安全</p><p>执行 <code>npm install -g webpack webpack-cli</code> 安装 Webpack</p><p>修改 <code>src</code> 下的 <code>index.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">[a, b, c] = [b, c, a + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr = [a, b, c];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> arr;</span><br></pre></td></tr></table></figure><p>在 <code>src</code> 下新建 <code>main.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="keyword">import</span> arr <span class="keyword">from</span> <span class="string">&quot;./index.js&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p>在根目录下定义一个 <code>webpack.config.js</code> 文件配置打包规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入path模块,nodejs的内置模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="comment">//定义JS打包的规则</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//指定构建的模式</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="comment">//入口函数从哪里开始进行编译打包</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">    <span class="comment">//编译成功以后要把内容输出到那里去</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//定义输出的指定的目录__dirname 当前项目根目录，将生成一个dist文件夹</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">        <span class="comment">//合并的js文件存储在dist/bundle.js文件中</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;res.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>终端执行 <code>webpack</code> 即可在 <code>dist</code> 文件夹中看到生成的 <code>res.js</code>，这就是合并后的 JavaScript 代码</p><p>通常在前端项目中，我们会将 Babel 和 Webpack 结合使用，使用 Babel 将最新版本的语法转换成向后兼容的代码，再由 Webpack 将这些代码打包并优化，最终生成浏览器可以解析的文件。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;库和框架&quot;&gt;&lt;a href=&quot;#库和框架&quot; class=&quot;headerlink&quot; title=&quot;库和框架&quot;&gt;&lt;/a&gt;库和框架&lt;/h2&gt;&lt;h4 id=&quot;库&quot;&gt;&lt;a href=&quot;#库&quot; class=&quot;headerlink&quot; title=&quot;库&quot;&gt;&lt;/a&gt;库&lt;/h4&gt;&lt;p&gt;库是一系列预先定义好的数据结构和函数或类的集合，程序员可以通过调用这些代码实现功能。简单来说就是库为我们提供了很多封装好的函数，看起来比较零散，但使用起来更灵活，只用取里面我们需要的某部分，再自己实现项目中其他部分得功能&lt;/p&gt;
&lt;p&gt;库就类似于 C 语言中的头文件，比如 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; 头文件提供了一系列常用的功能：&lt;code&gt;printf()&lt;/code&gt;、&lt;code&gt;scanf()&lt;/code&gt;、&lt;code&gt;gets()&lt;/code&gt;、&lt;code&gt;fopen()&lt;/code&gt; 等&lt;/p&gt;
&lt;p&gt;在前端开发中，使用库可以简化开发流程，提高开发效率。例如，jQuery 提供了简化 DOM 操作的语法，减少了编写繁琐代码的需要。React 通过虚拟 DOM 和声明式 UI ，便于快速构建用户界面&lt;/p&gt;
&lt;p&gt;如果需要在网页中使用 JavaScript 库，可以去网上下载库文件，放在网页的同一目录下，再到&lt;code&gt;script&lt;/code&gt;标签中引入。或者不下载通过通过链接在&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中引用该库即可：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;https://cdn.staticfile.org/jquery/3.4.0/jquery.min.js&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者在代码中通过 &lt;code&gt;require&lt;/code&gt; 或者 &lt;code&gt;import&lt;/code&gt; 中引入库。在现代的前端开发中，通常推荐使用 &lt;code&gt;import&lt;/code&gt; 来进行模块导入，特别是在使用现代 JavaScript 特性的项目中。这主要与现代 JavaScript 的发展趋势和语言特性有关&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 是 ES6 新引入的关键字，支持按需导入，而不需要导入整个模块。同时&lt;code&gt;import&lt;/code&gt; 的语法也比 &lt;code&gt;require&lt;/code&gt; 更直观清晰，更符合现代变成风格&lt;/p&gt;
&lt;p&gt;随着 JavaScript 生态的发展，越来越多的库和工具采用了 ES6 模块系统，使用 &lt;code&gt;import&lt;/code&gt; 能够更好地与这些现代化的工具和库进行集成。&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>现代 Web 应用开发与设计导论</title>
    <link href="https://houyi2333.github.io/2024/01/19/17-06-45/"/>
    <id>https://houyi2333.github.io/2024/01/19/17-06-45/</id>
    <published>2024-01-19T09:06:45.000Z</published>
    <updated>2024-03-10T11:37:17.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web-开发概况"><a href="#Web-开发概况" class="headerlink" title="Web 开发概况"></a>Web 开发概况</h2><p>Web 开发是指创建和维护网站、客户端程序、服务器与其他 Web 应用程序的过程。它包括使用不同的编程语言和技术来编写、测试和部署 Web 应用程序，以满足特定的业务需求和用户需求</p><p>通过 Web 开发技术，开发者能够设计实现诸多满足不同需求场景的应用程序，包括但不限于：网站开发、Android/IOS/Harmony OS NEXT 移动端应用程序、微信小程序、桌面应用、群聊机器人、游戏、浏览器插件、3D 建模、高性能服务器、分布式应用、虚拟现实应用、区块链、物联网设备……</p><span id="more"></span><p>前后端</p><p>在软件架构和程序设计领域，前端是软件系统中<strong>直接</strong>和用户交互的部分，而后端控制着软件的输出。将软件分为前端和后端是一种将软件不同功能的部分相互分离的抽象</p><p>在 Web 开发中，前端在绝大多数情况下指能够被用户直接访问与交互的模块，如网页、手机 App、桌面应用、小程序等。后端包括程序运行的后台服务器、存储数据的数据库以及其他数据中间件。大部分软件都概念性地分成了前端和后端，在大多数情况下，软件的后端经常是隐藏着而不被用户看到</p><p>狭义的前端通常是指网站或应用程序中与用户直接交互的部分。它是一种用于构建用户界面的技术和工具的集合，这些界面可以在 Web 浏览器中运行</p><p><img src="/2024/01/19/17-06-45/image-20240131193923031.png" alt="image-20240131193923031"></p><p>后端开发主要负责编写运行在服务端上的代码，通常来说，这部分的工作需要和数据库与 Web API 打交道，比如读写数据、读写文件、实现业务逻辑等。有些时候，业务逻辑存储在客户端，这时后台就是用来以 Web 服务的形式提供数据库中的数据</p><p><img src="/2024/01/19/17-06-45/image-20240131193927733.png" alt="image-20240131193927733"></p><p>开发者可以同时掌握前端和后端的技术，但大多数 Web 开发者都还是有一定的专精方向，甚至只在某一方面深入研究。尽管前后端是有天然的区别，但并没有规定它们各自的具体任务。有时前端只是完成数据的显示，而其他主要工作都在后端完成。但也有时，后端只是提供数据，而所有的计算和具体功能都在前端完成。前后端工作的分配，通常都是由项目的设计和架构来决定的</p><p><img src="/2024/01/19/17-06-45/image-20240131193852641.png" alt="image-20240131193852641"></p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器是用来检索、展示以及传递 Web 信息资源的应用程序。Web 信息资源由统一资源标识符 (Uniform Resource Identifier，URI) 所标记，它可以是一张网页、一张图片、一段视频或者任何在 Web 上所呈现的内容。使用者可以借助超链接，通过浏览器浏览互相关联的信息</p><p>浏览器内核 (Rendering Engine)，是指浏览器最核心的部分，负责对网页语法的解释（如标准通用标记语言下的一个应用 HTML、CSS、JavaScript）并渲染网页。通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同</p><h2 id="C-S-与-B-S-架构"><a href="#C-S-与-B-S-架构" class="headerlink" title="C/S 与 B/S 架构"></a><strong>C/S</strong> <strong>与</strong> <strong>B/S</strong> 架构</h2><p>C/S 架构是一种典型的两层架构，其全称是 Client/Server，即客户端服务器端架构，其客户端包含一个或多个在用户的电脑上运行的程序，而服务器端有两种，一种是数据库服务器端，客户端通过数据库连接访问服务器端的数据；另一种是 Socket 服务器端，服务器端的程序通过 Socket 与客户端的程序通信</p><p><img src="/2024/01/19/17-06-45/image-20240131193935031.png" alt="image-20240131193935031"></p><p>B/S 架构的全称为 Browser/Server，即浏览器/服务器结构。Browser 指的是 Web 浏览器，极少数事务逻辑在前端实现，但主要事务逻辑在服务器端实现。B/S 架构的系统无须特别安装，只有 Web 浏览器即可</p><p><img src="/2024/01/19/17-06-45/image-20240131193939509.png" alt="image-20240131193939509"></p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>超文本标记语言（Hyper Text Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。HTML 是一种基础技术，常与 CSS、JavaScript 一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取 HTML 文件，并将其渲染成可视化网页。HTML 描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>层叠样式表（Cascading Style Sheets）是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言。CSS3 现在已被大部分现代浏览器支持，而下一版的 CSS4 仍在开发中。CSS 不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript 是一种高级的、<strong>解释型</strong>的编程语言</p><p>JavaScript 是一门基于原型、头等函数的语言，是一门多范式的语言，它支持面向对象程序设计，指令式编程，以及函数式编程。它由 ECMA（欧洲电脑制造商协会）通过 ECMAScript 实现语言的标准化</p><p>ECMAScript 6.0（简称 ES6）是 JavaScript 语言的下一代标准，于 2015 年 6 月正式发布。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p><p>ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准</p><h2 id="计算机网络基础知识"><a href="#计算机网络基础知识" class="headerlink" title="计算机网络基础知识"></a>计算机网络基础知识</h2><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p>HTTP 是 _Hyper Text Transfer Protocol_（超文本传输协议）的缩写。HTTP 协议用于从 WWW 服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示 (如文本先于图形) 等。HTTP 是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。</p><p><img src="/2024/01/19/17-06-45/image-20240131193951317.png" alt="image-20240131193951317"></p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>在互联网上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫 URL（Uniform Resource Locator, 统一资源定位符）。</p><p>URL 由三部分组成：资源类型、存放资源的主机域名、资源文件名。</p><p>也可认为由 4 部分组成：协议、主机、端口、路径。</p><p>URL 的一般格式为：_protocol :// hostname [:port] / path / [:parameters] [?query] #fragment_</p><p><img src="/2024/01/19/17-06-45/image-20240131193059261.png" alt="image-20240131193059261"></p><h4 id="IP-地址和-DNS"><a href="#IP-地址和-DNS" class="headerlink" title="IP 地址和 DNS"></a>IP 地址和 DNS</h4><p>IP 地址（类似 192.168.1.1 内网网关）是互联网协议地址，它给因特网上的每台计算机和其它设备都规定了一个唯一的地址。由于有这种唯一的地址，才保证了用户在连网的计算机上操作时，能够高效而且方便地从千千万万台计算机中选出自己所需的对象来</p><p>但是 IP 地址毕竟是一串毫无规律的数字，并不方便人类的记忆和书写。因此在 IP 地址的基础上又发展出一种符号化的地址方案，来代替数字型的 IP 地址，每一个符号化的地址都与特定的 IP 地址对应。这个与网络上的数字型 IP 地址相对应的字符型地址，就是域名</p><p>类似 <a href="http://www.google.com">http://www.google.com</a> 这样的字符串就是“域名”，当访问 www.google.com 时，首先由 DNS（Domain Name System, DNS）域名系统解析为 IP 地址，随后再访问 IP</p><h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><p>HTTP 请求是指从<strong>客户端到服务器端</strong>的请求消息，请求报文由请求行 (Request line)、请求头 (Header)，空行、请求正文 4 部分组成</p><h4 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h4><p>在接收和解释请求消息后，服务器会返回一个 HTTP 响应消息。HTTP 响应报文也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p><h4 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h4><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。HTTP 方法描述了对给定资源的期望动作，每一种请求方法都抽象出了一种不同给定语义。</p><p>HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><p>在实际开发中 <strong>GET、POST、PUT、DELETE</strong> 四类 HTTP 方法的使用率最高，能够用一套统一的语法规范对资源的 CRUD (增删改查) 逻辑进行抽象</p><p>GET 方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据</p><p>POST 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</p><p>PUT 方法用请求有效载荷替换目标资源的所有当前表示</p><p>DELETE 方法删除指定的资源</p><p><img src="/2024/01/19/17-06-45/image-20240131194356603.png" alt="image-20240131194356603"></p><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求</p><p>状态码类型：</p><div class="table-container"><table><thead><tr><th>状态码</th><th>类别</th><th>原因</th></tr></thead><tbody><tr><td>1xx</td><td>信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>服务端错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table></div><p>常见的状态码：</p><p><strong>100 Continue</strong></p><p>客户端应继续其请求</p><p><strong>200 OK</strong></p><p>请求成功，一般用于 GET 与 POST 请求</p><p><strong>201 Created</strong></p><p>已创建，成功请求并创建了新的资源</p><p><strong>401 Unauthorized</strong></p><p>请求要求用户的身份认证</p><p><strong>403 Forbidden</strong></p><p>服务器理解请求客户端的请求，但是拒绝执行此请求</p><p><strong>404 Not Found</strong></p><p>服务器无法根据客户端的请求找到资源（网页）。</p><p><strong>500 Internal Server Error</strong></p><p>服务器内部错误，无法完成请求</p><h4 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a><strong>RESTful</strong> <strong>API</strong></h4><p>REST 全称是 Representational State Transfer，中文意思是表述性状态转移。</p><p>RESTful 架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。</p><p>接口应该使用标准的 HTTP 方法如 GET，PUT 和 POST，并遵循这些方法的语义。</p><p>REST 所谓的表述指的是对资源的表述。要让一个资源可以被识别，需要有个唯一标识，在 Web 中这个唯一标识就是 URI</p><p><img src="/2024/01/19/17-06-45/image-20240131194512617.png" alt="image-20240131194512617"></p><h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><h4 id="Git-版本控制工具"><a href="#Git-版本控制工具" class="headerlink" title="Git 版本控制工具"></a>Git 版本控制工具</h4><p>Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</p><p><img src="/2024/01/19/17-06-45/image-20240131194647849.png" alt="image-20240131194647849"></p><h4 id="GitHub-代码托管仓库"><a href="#GitHub-代码托管仓库" class="headerlink" title="GitHub 代码托管仓库"></a>GitHub 代码托管仓库</h4><p>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管</p><p><img src="/2024/01/19/17-06-45/image-20240131194651596.png" alt="image-20240131194651596"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Web-开发概况&quot;&gt;&lt;a href=&quot;#Web-开发概况&quot; class=&quot;headerlink&quot; title=&quot;Web 开发概况&quot;&gt;&lt;/a&gt;Web 开发概况&lt;/h2&gt;&lt;p&gt;Web 开发是指创建和维护网站、客户端程序、服务器与其他 Web 应用程序的过程。它包括使用不同的编程语言和技术来编写、测试和部署 Web 应用程序，以满足特定的业务需求和用户需求&lt;/p&gt;
&lt;p&gt;通过 Web 开发技术，开发者能够设计实现诸多满足不同需求场景的应用程序，包括但不限于：网站开发、Android/IOS/Harmony OS NEXT 移动端应用程序、微信小程序、桌面应用、群聊机器人、游戏、浏览器插件、3D 建模、高性能服务器、分布式应用、虚拟现实应用、区块链、物联网设备……&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>唉，计组</title>
    <link href="https://houyi2333.github.io/2024/01/07/17-04-19/"/>
    <id>https://houyi2333.github.io/2024/01/07/17-04-19/</id>
    <published>2024-01-07T09:04:19.000Z</published>
    <updated>2024-03-10T10:56:36.185Z</updated>
    
    <content type="html"><![CDATA[<p>今天是个特殊的日子：赖晓晨的计组出分了</p><p>好消息是分数还不错，在期末考试几乎没有会的题的情况下竟然拿到了 80 分，这说明赖晓晨在中等成绩段上给分还是不错的</p><p>听说去年最高分也只有 88 分，可能确实是在他手上很难拿高分吧</p><span id="more"></span><hr><p><strong>_以下是正文：_</strong></p><p>首先恭喜同学成功的选上了赖晓晨老师的计算机组织与结构这门课</p><p>赖晓晨非常喜欢华为这个企业，上课会穿插极其多的华为的内容，期末考试也会涉及一些华为的内容，尤其是华为的鲲鹏处理器</p><p>赖晓晨老师上课的流程是，先扫码进雨课堂，课中会时不时在雨课堂发送测试题，并且每道题只有 30-60s 的时间来作答，如果翘课是很难通过别人提醒来及时作答的。同时，课上还会提问坐在后排的学生，如果没答上来，还会要求该学生坐到第一排。后来你会发现，教室里只有前 5 排有学生，后面一个都没有。同时，上课抢答的同学会记名，加平时分。同时，还会有翻转课堂，也就是学生讲课，自愿报名，报名的加平时分。同时，成绩构成也很复杂，各种形式五花八门，给大家看一下成绩构成</p><p><img src="/2024/01/07/17-04-19/image-20240107170838300.png" alt="image-20240107170838300"></p><p>课后作业包括两部分，一部分是课本课后习题，会挑一些做，这个没什么问题，量也不多，与其他老师都一样。但是其他老师的平时成绩也就是这些课后习题了，而赖晓晨老师为了让学生全面发展，课后作业又新增了一项——代码作业</p><p>代码作业我这一届是有 5 个，如下图：</p><p><img src="/2024/01/07/17-04-19/image-20240107170921333.png" alt="image-20240107170921333"></p><p>这个代码作业是线上提交 C 语言代码，但是这个代码的难度。。。反正我写不出来，并且 ChatGPT 也写不出来。作业的 1003，我的代码通过了课本所有的例题，但是就是通不过他给的样例，最后喜提 75 分</p><p>同时，这个作业的代码会进行查重，如果你跟另一个同学的代码相似度过高，两个人本次作业会被直接判为 0 分。</p><p>同时，赖晓晨老师还设置了课内实验和微认证这两个部分</p><p>课内实验是什么呢，是赖晓晨老师亲手写的<strong>122 页</strong>PDF，这个 PDF 教给了你如何租用华为鲲鹏 920 服务器，如何使用 open Euler 操作系统，如何编写 ARMV8 汇编程序，如何对汇编代码进行优化等等内容，并且还有每一个实验都紧跟着一个思考题，每一个实验不做思考题大概耗时 1.5h。但是如果考虑到用电脑时诸如水群和看视频等其他操作，可能需要一晚上甚至更多时间才能做完一个实验。总共有 5 个实验需要做。</p><p>这个实验对于没有服务器租用经验和 Linux 系统使用经验的同学来说，我个人认为还是有挑战性的，open Euler 是一个没有 GUI 的操作系统，仅能使用 shell 命令和 vim 编辑器进行操作</p><p>接下来讲微认证的 5 分</p><p>这个微认证的内容是华为鲲鹏处理器知识，有很多的课可以选，只要完成必做的一个+任选一个，共完成两个，就可以拿到这五分</p><p><img src="/2024/01/07/17-04-19/image-20240107171104951.png" alt="image-20240107171104951"></p><p><img src="/2024/01/07/17-04-19/image-20240107171643108.png" alt="image-20240107171643108"><img src="/2024/01/07/17-04-19/image-20240107171650661.png" alt="image-20240107171650661"></p><p>这个微认证，每个课都是需要花费一张代金券的，代金券一个周能且仅能领一张，且限量 500 张，如果被抢没了，那这个周你想做也做不了了</p><p>当然，上述还没有考虑到大作业，当然大作业是选做的，也不知道做大作业是更容易及格还是更不容易及格</p><p>大作业的要求是，根据那<strong>122 页</strong>PDF 给出的实验，自己创新性的提出新的实验，实验内容要求与鲲鹏处理器技术的内容高度相关，实验文档的结构也要与实验手册一致，包括实验目的、实验设备、实验原理、实验任务操作指导以及思考题。由于我们并没有深入学习过鲲鹏 920 处理器，也不了解 ARMV8 架构和 Linux 操作系统，也不了解处理器内部结构，个人认为想要设计这个实验还是很难的，虽然我当年选择了做大作业，自己设计了一个实验）</p><p>大作业也不像其他老师一样交上去就完事了，需要三个人一起组队完成，要开题答辩，最终答辩，开题答辩还需要刷人，最终答辩如果不理想也要被刷掉。被刷掉了成绩构成就要回归第一种方案，也就是没有大作业，所以即使做了大作业，赖晓晨老师也不一定会让允许你的大作业计入期末成绩，可能会前功尽弃。</p><p>本人对赖晓晨老师的评价是，讲课极其认真，如果认真完成每一个作业，真的可以学到很多在其他老师课堂上学不到的东西，但是从成绩的角度讲，确实不容易拿到很高的分数。并且选他的课事情会极其极其极其的多，想摆烂求及格的同学千万不要选，会忙的你痛不欲生</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天是个特殊的日子：赖晓晨的计组出分了&lt;/p&gt;
&lt;p&gt;好消息是分数还不错，在期末考试几乎没有会的题的情况下竟然拿到了 80 分，这说明赖晓晨在中等成绩段上给分还是不错的&lt;/p&gt;
&lt;p&gt;听说去年最高分也只有 88 分，可能确实是在他手上很难拿高分吧&lt;/p&gt;</summary>
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>具体数学笔记</title>
    <link href="https://houyi2333.github.io/2024/01/04/18-38-27/"/>
    <id>https://houyi2333.github.io/2024/01/04/18-38-27/</id>
    <published>2024-01-04T10:38:27.000Z</published>
    <updated>2024-03-31T03:01:46.334Z</updated>
    
    <content type="html"><![CDATA[<p>这门课在大工只有软院开，并且极其的抽象，虽然他叫具体数学</p><p>这门课的虽然很抽象，但是考试很简单，全部源自 PPT 和作业题，几乎连数都不变</p><p>这里在知识点上进行了一下总结（其实就是把 PPT 用人话说了一遍），建议先看会知识点，再看 PPT 的题，再看作业题</p><p>下载链接：<a href="./note.pdf" download>具体数学笔记</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这门课在大工只有软院开，并且极其的抽象，虽然他叫具体数学&lt;/p&gt;
&lt;p&gt;这门课的虽然很抽象，但是考试很简单，全部源自 PPT 和作业题，几乎连数都不变&lt;/p&gt;
&lt;p&gt;这里在知识点上进行了一下总结（其实就是把 PPT 用人话说了一遍），建议先看会知识点，再看 PPT 的题，再</summary>
      
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>VSCode自动格式化.c and .cpp文件并开启自动保存</title>
    <link href="https://houyi2333.github.io/2023/10/06/13-11-21/"/>
    <id>https://houyi2333.github.io/2023/10/06/13-11-21/</id>
    <published>2023-10-06T05:11:21.000Z</published>
    <updated>2024-03-10T10:57:07.582Z</updated>
    
    <content type="html"><![CDATA[<p>打开 VSCode 的设置，搜索 Format ，将搜索到的选项设置成如下格式，这样就打开了自动格式化</p><p><img src="/2023/10/06/13-11-21/3cfc97729ba949edbac614d0d90e00b1.png" alt="3cfc97729ba949edbac614d0d90e00b1"></p><span id="more"></span><p>在设置中搜索 Auto Save ，将 <code>Files: Auto Save</code> 改为 <code>onFocusChange</code>，这样就开启了自动保存</p><p><img src="/2023/10/06/13-11-21/36e4dcbc98ac4282a2359ca9da791d36.png" alt="36e4dcbc98ac4282a2359ca9da791d36"><br>还有一个让强迫症患者很头大的问题：大括号是换行还是不换行？</p><p><img src="/2023/10/06/13-11-21/00224dc01a8e4a72a668a8e10456ec2c.png" alt="00224dc01a8e4a72a668a8e10456ec2c"><br>在设置中搜索 C_Cpp.Clang_format_style ，填入 <code>&#123;BasedOnStyle: Chromium, IndentWidth: 4&#125;</code></p><p><img src="/2023/10/06/13-11-21/f57336ae3841440183321d629da7b7d9.png" alt="f57336ae3841440183321d629da7b7d9"><br>这样大括号就不会换行</p><p><img src="/2023/10/06/13-11-21/899708edb6dd4be0b39371828a9f8ec2.png" alt="899708edb6dd4be0b39371828a9f8ec2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打开 VSCode 的设置，搜索 Format ，将搜索到的选项设置成如下格式，这样就打开了自动格式化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/10/06/13-11-21/3cfc97729ba949edbac614d0d90e00b1.png&quot; alt=&quot;3cfc97729ba949edbac614d0d90e00b1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="VSCode" scheme="https://houyi2333.github.io/categories/VSCode/"/>
    
    
  </entry>
  
  <entry>
    <title>大连理工大学软件学院新生学习指南</title>
    <link href="https://houyi2333.github.io/2023/09/22/20-57-01/"/>
    <id>https://houyi2333.github.io/2023/09/22/20-57-01/</id>
    <published>2023-09-22T12:57:01.000Z</published>
    <updated>2024-03-10T10:56:54.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大一上学期课程简介以及成绩计算相关"><a href="#大一上学期课程简介以及成绩计算相关" class="headerlink" title="大一上学期课程简介以及成绩计算相关"></a>大一上学期课程简介以及成绩计算相关</h2><p>软件学院大一上学期的课程有：大学生心理健康教育（<strong>2 学分</strong>）、大学英语 1（<strong>2 学分</strong>）、健康教育（<strong>0.5 学分</strong>）、计算机系统实践（<strong>1 学分</strong>）、体育-基础 1（<strong>0.5 学分</strong>）、信息技术导论（<strong>1 学分</strong>）、思想道德与法治（<strong>2.5 学分</strong>）、程序设计基础与 C 语言程序设计（<strong>4 学分</strong>）、工科数学分析基础 1（<strong>5 学分</strong>）、军训（<strong>2 学分</strong>）</p><p>（大学的课程都有简称，以上课程简称依次为：心理健康，大英 1，健康教育，计算机系统实践、体育、导论课、思修，思政、C 语言、工数 1，高数 1，微积分 1，军训）</p><p>其中计入保研的有：大英 1、计算机系统实践、导论、思政、C 语言、工数 1、军训</p><p>大学的排名是根据均分排的，均分由平均成绩、单项奖学金、竞赛、论文等组成，平均成绩的计算公式是：</p><script type="math/tex; mode=display">\text{假设课程}n\text{的分数为}M_n\text{，学分为}N_n\text{那么你的平均成绩为}\frac{\sum_{i=1}^n{M_i\times N_i}}{\sum_{j=1}^n{N_j}}</script><span id="more"></span><p><code>注：以下评分标准与授课内容仅适用于22级，其他年级若有出入属于正常情况</code></p><h2 id="这些课是学什么的，以及容不容易挂科"><a href="#这些课是学什么的，以及容不容易挂科" class="headerlink" title="这些课是学什么的，以及容不容易挂科"></a>这些课是学什么的，以及容不容易挂科</h2><h4 id="心理健康"><a href="#心理健康" class="headerlink" title="心理健康"></a>心理健康</h4><p>心理健康就是字面意思，会讲大学生如何才能保持一个正常的心理状态，有不正常的心理状态会怎么样。目前没有正常人挂过科</p><h4 id="大英-1"><a href="#大英-1" class="headerlink" title="大英 1"></a>大英 1</h4><p>巨厚的课本，老师会讲里面的课文，讲里面的单词和句子，还有阅读理解。目前没有正常人挂过科</p><h4 id="健康教育"><a href="#健康教育" class="headerlink" title="健康教育"></a>健康教育</h4><p>会讲常见疾病，得病了后如何自我诊断，如何正确就医。虽然课程简单，但是普遍低分且有部分人挂科</p><h4 id="计算机系统实践"><a href="#计算机系统实践" class="headerlink" title="计算机系统实践"></a>计算机系统实践</h4><p>教装机、装系统，上课跟着实操，下课后交报告。目前没有正常人挂过科</p><h4 id="体育"><a href="#体育" class="headerlink" title="体育"></a>体育</h4><p>体育学什么要看你选的什么课，由于我不可能上过所有体育课，无法下结论是否容易挂科</p><h4 id="信息技术导论"><a href="#信息技术导论" class="headerlink" title="信息技术导论"></a>信息技术导论</h4><p>每节课都会请一个巨佬来作报告，讲前沿知识，然后课下写论文交作业。目前没有正常人挂过科</p><h4 id="思想道德与法治"><a href="#思想道德与法治" class="headerlink" title="思想道德与法治"></a>思想道德与法治</h4><p>类似于高中政治课，凭借朴素的爱国情怀就可以及格，你要是挂科了建议出门左转去大连市公安局经济技术开发区分局自首</p><h4 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h4><p>字面意思就学 C 语言，有挂科的，但是不多，不容易挂（==_注意，软件学院 C 语言不是在电脑上考试，是纸质试卷手写代码，禁止使用任何电子设备_==）</p><h4 id="工科数学分析基础-1"><a href="#工科数学分析基础-1" class="headerlink" title="工科数学分析基础 1"></a>工科数学分析基础 1</h4><p>跟高等数学学的几乎一样，是大一<strong>最容易</strong>挂科的课</p><h4 id="军训"><a href="#军训" class="headerlink" title="军训"></a>军训</h4><p><del>只要别跟教官和导员打起来就不会挂科</del></p><h2 id="计入保研的课怎么学-怎么考试"><a href="#计入保研的课怎么学-怎么考试" class="headerlink" title="计入保研的课怎么学/怎么考试"></a>计入保研的课怎么学/怎么考试</h2><h4 id="大英-1-1"><a href="#大英-1-1" class="headerlink" title="大英 1"></a>大英 1</h4><p>平时会有测试，测试内容以及答案我都放在 NAOSI 的 GitHub 仓库了，为了高分可以提前把题直接背下来。期末考试前会有口语考试，形式是老师面前摆了 15 张卡片，一张卡片有一段话，这些段落都是平时学的课文里的。先把这段话读给老师听，然后老师会根据内容提问问题，问题可能是与课文内容相关的，要求对课文很熟悉，也有可能是开放性问题，比如我当时的问题就是平时会怎么做计划，考察口语能力。期末考试的形式是听力+阅读+单词，单词就是平时测试的，题目都给你们了背下来就行了，听力和阅读都是课外的，跟高中一样</p><h4 id="计算机系统实践-1"><a href="#计算机系统实践-1" class="headerlink" title="计算机系统实践"></a>计算机系统实践</h4><p>好好上课动手多操作一下，不要学计算机的对计算机一窍不通。不要像你们某学长一样，学计算机的不会装系统，不会加固态，甚至不会解压 rar。成绩是根据课下写的报告给的，建议里面图多一点，文字多水一点。（反正老师不管你怎么写的，你可以百度甚至跟历届学长要啊）</p><h4 id="信息技术导论-1"><a href="#信息技术导论-1" class="headerlink" title="信息技术导论"></a>信息技术导论</h4><p>好好水论文字数，好好调整好论文格式就行，给的分数相差不大</p><h4 id="思想道德与法治-1"><a href="#思想道德与法治-1" class="headerlink" title="思想道德与法治"></a>思想道德与法治</h4><p>思政想要考高分还是要多背一背课本的，期末考的题全部是选择题，可以参考 NAOSI 仓库里的题库。不过本人思想觉悟不够高，思政学的并不好，不能给学弟提一些有效的建议</p><h4 id="C-语言-1"><a href="#C-语言-1" class="headerlink" title="C 语言"></a>C 语言</h4><p>C 语言是软件工程课程的基础，这门课虽然教的极其老套，考试极其死板，但是如果学的不好，也很打击一个软件工程学生的自信心，会自身怀疑是否适合学软件工程这个专业。作为计算机专业的科班生，建议不要仅仅局限于课堂上老师教的内容，要以 C 语言为中心，自学其他内容。比如老师上课不会讲到的文件、算法设计，或者开发方面的。如果仅仅应付考试，多看老师发的 PPT，多看老师上课带着写的程序，学不会的去 b 站自己搜视频，或者查阅相关文档</p><h4 id="工科数学分析基础-1-1"><a href="#工科数学分析基础-1-1" class="headerlink" title="工科数学分析基础 1"></a>工科数学分析基础 1</h4><p>工数 1 是从成绩上讲整个大一最最最最重要的课，与高中数学内容相关性比较高。工数 1 的成绩组成比较复杂，由作业+过程考核+MOOC 平台+期末考试组成，期末考试占 40%，平时占 60%。作业就是老师布置的作业，认真完成按时上交即可。过程考核一共有 3 次，时间听老师安排，一般是每一章讲完后的下周五，一次过程考核计入期末的 10 分，三次共 30 分，非常重要。过程考核内容为选择题+判断题，只考一章的内容，算是小型期中考试。并且过程考核的题目难度要大于期末考试，还会出一些比较恶心的卡概念的题，但考试的题目是从超级大的题库里抽的，题目难度与运气有关。过程考核的时间不是同一个时间，如果你是下午考的，可以利用自己的人际关系问一下上午都考了些什么，脸好的话会遇到原题。MOOC 平台就是线上完成作业，还有同学间互评打分，非常好得分，就是白送你的，但是总有人会忘记写 MOOC，或者写完了忘记互评，这些都会影响分数。期末考试由选择题和大题组成，比高中数学还老套，都是固定题型，想考高分平时就要刷题刷题还是刷题，刷考研题刷竞赛题，期末经常会从历年的考研或竞赛中拿几道改编一下。NAOSI 仓库里有个文件叫“每天起床头件事，先背一遍展开式”，是工数 1 和工数 2（这门课大一下要学）的复习提纲，有需要的自取</p><h4 id="军训-1"><a href="#军训-1" class="headerlink" title="军训"></a>军训</h4><p>不知道怎么得高分</p><h3 id="后记（改编自-20-级某-m-姓学长）"><a href="#后记（改编自-20-级某-m-姓学长）" class="headerlink" title="后记（改编自 20 级某 m 姓学长）"></a>后记（改编自 20 级某 m 姓学长）</h3><p>无论成绩如何，一名软件工程专业的学生都应该在本科阶段掌握以下技能：</p><ul><li>自学</li><li>规范代码格式</li><li>熟练使用 IDE（ VSCode 严格来说不属于 IDE 但依然是宇宙第一）</li><li>阅读 API</li><li>阅读文档</li><li>数据结构与算法</li><li>英文读写</li><li>版本控制工具（Git）和开源仓库（GitHub/Gitee）的使用</li><li>撰写 LaTeX/Markdown 文档</li><li>答辩 （字面意思）</li></ul><h3 id="NAOSI-的-GitHub-仓库"><a href="#NAOSI-的-GitHub-仓库" class="headerlink" title="NAOSI 的 GitHub 仓库"></a>NAOSI 的 GitHub 仓库</h3><p>链接：<a href="https://github.com/NAOSI-DLUT/DLUT_SE_Courses">https://github.com/NAOSI-DLUT/DLUT_SE_Courses</a></p><p>这个仓库是干什么的呢，里面有：</p><ul><li>学长学姐亲传的资料</li><li>你寻找很久的电子参考书</li><li>前人细心雕琢出的大作业</li><li>历年真题</li><li><p>上完一门课才恍然领悟的技巧</p><p>2023.10.9 补充：<br>上午看见某学长在某个群里发表言论称，考前一个月突击一下，足够考门门 90 拿学习奖学金了，对于这个言论我的意见是，你们可以自己试试看，反正我做不到</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;大一上学期课程简介以及成绩计算相关&quot;&gt;&lt;a href=&quot;#大一上学期课程简介以及成绩计算相关&quot; class=&quot;headerlink&quot; title=&quot;大一上学期课程简介以及成绩计算相关&quot;&gt;&lt;/a&gt;大一上学期课程简介以及成绩计算相关&lt;/h2&gt;&lt;p&gt;软件学院大一上学期的课程有：大学生心理健康教育（&lt;strong&gt;2 学分&lt;/strong&gt;）、大学英语 1（&lt;strong&gt;2 学分&lt;/strong&gt;）、健康教育（&lt;strong&gt;0.5 学分&lt;/strong&gt;）、计算机系统实践（&lt;strong&gt;1 学分&lt;/strong&gt;）、体育-基础 1（&lt;strong&gt;0.5 学分&lt;/strong&gt;）、信息技术导论（&lt;strong&gt;1 学分&lt;/strong&gt;）、思想道德与法治（&lt;strong&gt;2.5 学分&lt;/strong&gt;）、程序设计基础与 C 语言程序设计（&lt;strong&gt;4 学分&lt;/strong&gt;）、工科数学分析基础 1（&lt;strong&gt;5 学分&lt;/strong&gt;）、军训（&lt;strong&gt;2 学分&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;（大学的课程都有简称，以上课程简称依次为：心理健康，大英 1，健康教育，计算机系统实践、体育、导论课、思修，思政、C 语言、工数 1，高数 1，微积分 1，军训）&lt;/p&gt;
&lt;p&gt;其中计入保研的有：大英 1、计算机系统实践、导论、思政、C 语言、工数 1、军训&lt;/p&gt;
&lt;p&gt;大学的排名是根据均分排的，均分由平均成绩、单项奖学金、竞赛、论文等组成，平均成绩的计算公式是：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
&#92;text{假设课程}n&#92;text{的分数为}M_n&#92;text{，学分为}N_n
&#92;text{那么你的平均成绩为}&#92;frac{&#92;sum_{i=1}^n{M_i&#92;times N_i}}{&#92;sum_{j=1}^n{N_j}}&lt;/script&gt;</summary>
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>如何使用 VSCode 编译运行 .c and .cpp 文件</title>
    <link href="https://houyi2333.github.io/2023/09/21/23-05-53/"/>
    <id>https://houyi2333.github.io/2023/09/21/23-05-53/</id>
    <published>2023-09-21T15:05:53.000Z</published>
    <updated>2024-03-10T10:57:03.795Z</updated>
    
    <content type="html"><![CDATA[<p>首先先介绍一下 VSCode 是个什么东西</p><p>VSCode 是一款<strong>轻量级</strong>的<strong>代码编辑器</strong>，可以通过安装各种各样不同<strong>扩展</strong>的方式来实现开发者所需要的功能。</p><p>代码编辑器事实上我们可以看成是一个记事本（没错，就是你按下 Win+R 输入 notepad 回车之后的那个记事本），其最基本的功能是文档编辑。不过之所以将其称为是代码编辑器，是因为它虽然继承自一般的文档编辑器，又具备了一些一般的文档编辑器所不具备的功能。具体来说，例如自动语法高亮，自动补全，甚至是自动代码重构等等。<br>集成开发环境（IDE）是一种用于构建应用程序的软件，可将常用的开发人员工具合并到单个图形用户界面（GUI）中。具体来说，我们只需要简单的点击按钮，可能就可以完成程序的编译、链接、运行、调试等等工作。而这些工作在最初都是需要人手工在命令行中完成的。我们在《程序设计基础与 C 程序设计》课程中最初使用的 Dev-C++ 便是一个集成开发环境。<br>我们今天要介绍的 VSCode 是一款轻量级的代码编辑器。如果没有各种扩展插件的支持的话，可能我们只能把它称作是大号的记事本，而正是因为社区中各种各样的扩展，VSCode 才得以展现其强大。</p><span id="more"></span><h2 id="安装-VSCode"><a href="#安装-VSCode" class="headerlink" title="安装 VSCode"></a>安装 VSCode</h2><p>让我们打开 VSCode 官网：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p><p>点击红框里的 <code>Download for Windows</code>，之后浏览器就会自动下载</p><p><img src="/2023/09/21/23-05-53/1.png" alt="1"></p><p><img src="/2023/09/21/23-05-53/2.png" alt="2"></p><p><img src="/2023/09/21/23-05-53/3.png" alt="3">选择我同意此协议</p><p><img src="/2023/09/21/23-05-53/4.png" alt="4">五个复选框全部都打勾</p><p><img src="/2023/09/21/23-05-53/5.png" alt="5">点击安装</p><p>这样我们就能成功打开 VSCode</p><p><img src="/2023/09/21/23-05-53/6.png" alt="6"></p><h2 id="汉化-VSCode"><a href="#汉化-VSCode" class="headerlink" title="汉化 VSCode"></a>汉化 VSCode</h2><p>我们可以通过安装中文插件将其汉化</p><p><img src="/2023/09/21/23-05-53/7.png" alt="7"></p><p>重启后我们就得到了中文 VSCode</p><p><img src="/2023/09/21/23-05-53/8.png" alt="8"></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>我们可以先打开终端，尝试输入：<code>g++ --version</code></p><p>如果你的终端返回了 g++ 的版本信息，恭喜，您 C++ 编译器的环境变量配置正确，可以跳过这一章</p><p>如果你的终端返回了：<code>&#39;g++&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件。</code>那么则说明你的终端不知道 <code>g++</code> 是什么命令，接下来需要根据我的教程添加环境变量</p><p>什么是环境变量？</p><p>当你的 Shell 在执行命令时，会尝试在<strong>一系列路径</strong>下搜索同名的可执行文件。这一系列路径我们就称作是环境变量。</p><p>Windows 用户可以在终端中输入 path 来查看当前环境变量（由于我进行过一系列配置，所以其输出结果可能与你的不同）：</p><p><img src="/2023/09/21/23-05-53/image-20240119095335965.png" alt="image-20240119095335965"></p><p>没错，就是这一系列文件夹。回忆我们刚才执行 <code>g++ --version</code> 命令的时候，我们的终端会在这一系列文件夹下为我们寻找叫做 <code>g++</code> 的可执行文件。如果找到了名为 <code>g++</code> 的可执行文件，我们的终端就会将参数传入，将其执行；而如果我们的终端没有找到，那么就会向我们报告“未知命令”。</p><p>我们刚刚已经理解了环境变量的运行逻辑，接下来我们讲解如何进行环境变量的配置。</p><p>对于 Windows 用户，请按下 Windows + S 打开搜索框，在其中输入 <code>path</code>，然后选择”环境变量”，然后选择“系统变量”中的 Path 字段，双击打开后即可配置。</p><p>接下来我们安装 MinGW64</p><p>MinGW 的全称是：Minimalist GNU on Windows。</p><p>它实际上是将经典的开源 C 语言编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux 平台下的开发工具。</p><p>一句话来概括：MinGW 就是 GCC 的 Windows 版本。这是将你写的 C/C++ 语言的源代码编译成汇编代码，进而链接成可执行文件的工具。之前我们的 Dev-C++ 事实上也集成了这个工具。</p><p>我们下载官方的安装工具（<a href="https://sourceforge.net/projects/mingw/">链接</a>），下载完成后打开，无需进行更改，一路点击下一步</p><p>安装完成之后会自动打开 MinGW Installation Manager</p><p>我们点击左侧栏中的 Basic Setup ，右侧勾选 mingw32-base 和 mingw32-gcc-g++ 这两个包</p><p><img src="/2023/09/21/23-05-53/image-20240119101136811.png" alt="image-20240119101136811"></p><p>之后点击菜单栏中 Installation 的 Apply Changes</p><p><img src="/2023/09/21/23-05-53/image-20240119101243586.png" alt="image-20240119101243586"></p><p>等待片刻，MinGW 即可安装在你的电脑中</p><p>然后，我们需要进行环境变量配置。进入 <code>Mingw64 的安装路径/mingw64/bin/</code>，我们可以看到 <code>gcc</code>，<code>g++</code> 这些我们熟悉的可执行文件。<strong>然后我们需要做的就是将这个文件夹添加至环境变量中。</strong></p><p><img src="/2023/09/21/23-05-53/cb23ba556a7b40a59cd40145b2ac89d4.png" alt="cb23ba556a7b40a59cd40145b2ac89d4"></p><p>然后我们就可以打开终端，输入 <code>g++ --version</code> 验证环境变量是否配置成功。（请注意，在环境变量配置后需要重启终端才能生效）</p><h2 id="插件安装与设置"><a href="#插件安装与设置" class="headerlink" title="插件安装与设置"></a>插件安装与设置</h2><p>这时候我们再装两个插件，一个叫 C/C++，一个叫 Code Runner</p><p><img src="/2023/09/21/23-05-53/6cd952d979ef4a7b994518d2c8c27c56.png" alt="6cd952d979ef4a7b994518d2c8c27c56"> <img src="/2023/09/21/23-05-53/2321a98cae5c4830b875837cf552685d.png" alt="2321a98cae5c4830b875837cf552685d"></p><p>然后我们在设置里搜索 code-runner.runInTerminal ，勾选这一项</p><p><img src="/2023/09/21/23-05-53/6f0c3688f1a349eca85d1118e620b2d0.png" alt="6f0c3688f1a349eca85d1118e620b2d0"></p><h2 id="VSCode，启动！"><a href="#VSCode，启动！" class="headerlink" title="VSCode，启动！"></a>VSCode，启动！</h2><p>之后我们点击这个按钮就能在内部终端运行.c 程序了</p><p><img src="/2023/09/21/23-05-53/ac14f764aa4a4bc2a087b9a90821bc9f.png" alt="ac14f764aa4a4bc2a087b9a90821bc9f"></p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>那如果你习惯了用外部终端，可以这样设置一下</p><p>在设置中搜索 code-runner.languageIdToFileExtensionMap ，并在 setting. Son 中编辑文件</p><p>在”code-runner.executorMap”这个对象键中加入以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;code-runner.executorMap&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;cpp&quot;</span>: <span class="string">&quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;c&quot;</span>: <span class="string">&quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先先介绍一下 VSCode 是个什么东西&lt;/p&gt;
&lt;p&gt;VSCode 是一款&lt;strong&gt;轻量级&lt;/strong&gt;的&lt;strong&gt;代码编辑器&lt;/strong&gt;，可以通过安装各种各样不同&lt;strong&gt;扩展&lt;/strong&gt;的方式来实现开发者所需要的功能。&lt;/p&gt;
&lt;p&gt;代码编辑器事实上我们可以看成是一个记事本（没错，就是你按下 Win+R 输入 notepad 回车之后的那个记事本），其最基本的功能是文档编辑。不过之所以将其称为是代码编辑器，是因为它虽然继承自一般的文档编辑器，又具备了一些一般的文档编辑器所不具备的功能。具体来说，例如自动语法高亮，自动补全，甚至是自动代码重构等等。&lt;br&gt;集成开发环境（IDE）是一种用于构建应用程序的软件，可将常用的开发人员工具合并到单个图形用户界面（GUI）中。具体来说，我们只需要简单的点击按钮，可能就可以完成程序的编译、链接、运行、调试等等工作。而这些工作在最初都是需要人手工在命令行中完成的。我们在《程序设计基础与 C 程序设计》课程中最初使用的 Dev-C++ 便是一个集成开发环境。&lt;br&gt;我们今天要介绍的 VSCode 是一款轻量级的代码编辑器。如果没有各种扩展插件的支持的话，可能我们只能把它称作是大号的记事本，而正是因为社区中各种各样的扩展，VSCode 才得以展现其强大。&lt;/p&gt;</summary>
    
    
    
    <category term="VSCode" scheme="https://houyi2333.github.io/categories/VSCode/"/>
    
    
  </entry>
  
</feed>
