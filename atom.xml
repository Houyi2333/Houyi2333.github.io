<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你不定积分没加C的博客</title>
  
  <subtitle>除了不定积分，还有微分方程通解需要+C</subtitle>
  <link href="https://houyi2333.github.io/atom.xml" rel="self"/>
  
  <link href="https://houyi2333.github.io/"/>
  <updated>2024-01-22T03:33:57.628Z</updated>
  <id>https://houyi2333.github.io/</id>
  
  <author>
    <name>你不定积分没加C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 JavaScript 到 TypeScript</title>
    <link href="https://houyi2333.github.io/2024/01/21/17-16-23/"/>
    <id>https://houyi2333.github.io/2024/01/21/17-16-23/</id>
    <published>2024-01-21T09:16:23.000Z</published>
    <updated>2024-01-22T03:33:57.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是TypeScript？"><a href="#什么是TypeScript？" class="headerlink" title="什么是TypeScript？"></a>什么是TypeScript？</h2><p>简而言之，TypeScript 是 JavaScript 的超集，它继承了 JavaScript 所有的语法，并且可以编译为纯 JavaScript 。它的目的并不是创造一种全新语言，而是增强 JavaScript 的功能，使其更适合多人合作的企业级项目。</p><p>既然是超集，那么它<strong>超</strong>在哪里呢？</p><p>我们知道， JavaScript 的变量是没有类型的，无论用 <code>var, let, const</code> 哪一个关键字，都无法指定变量的类型，因此我们称 JS 是一个“弱类型”的语言。例如下面的代码，在 JavaScript 中是完全合法的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;34&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = a + str; <span class="comment">// res = &quot;134&quot;</span></span><br></pre></td></tr></table></figure><p>这对我们来说是非常不好的，是反直觉的，正常人的思维应该是，一个数字和字符串怎么可能可以相加呢？这应该报错！</p><p>TypeScript 最大的特点就是引入了类型系统，这样就可以在编译为 JavaScript 代码之前由编译器进行类型检查。在这样的条件下，TypeScript 中的变量在声明的时候就可以指定类型，编译器在将 TypeScript 代码编译为 JavaScript 代码的时候会进行类型检查，若有不符合类型声明的情况则会报错：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = (<span class="attr">name</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">2</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>上面的 <code>fun</code> 函数要求传入一个 <code>string</code> 类型的值，且返回类型为 <code>void</code> 但是我们调用的时候却传入了一个数字2，这显然是不符合函数参数要求的，因此 TypeScript 编译器会报错</p><p>TypeScript 有着静态类型检查，具有类型系统，可以在开发时捕获许多常见的错误。通过类型检查，可以在编码阶段就发现潜在的问题，减少运行时错误。因此我们更推荐使用 TypeScript 进行项目开发，而不是 JavaScript</p><h2 id="TypeScript，启动！"><a href="#TypeScript，启动！" class="headerlink" title="TypeScript，启动！"></a>TypeScript，启动！</h2><p> Node.js 提供了 npm 包管理器，通过<code>npm install -g typescript</code> 即可安装 TypeScript 。通过 <code>tsc</code> 命令即可将 TypeScript 代码编译为 JavaScript 代码。但是它并不支持直接运行编译后的代码，而 <code>ts-node</code> 正好填补了这一空缺，它封装了 TypeScript 的编译过程，使得 TypeScript 代码无需编译成 JavaScript，就能直接运行 TypeScript 代码。由于这是一个教学文档，本文先不使用 <code>ts-node</code></p><p>我们在一个文件夹下启动命令行，输入 <code>npm install -g typescript</code> 安装 TypeScript ，之后输入 <code>tsc --init</code>即可在当前文件夹下初始化 TypeScript 项目。我们会发现当前文件夹下多了一个 <code>tsconfig.json</code> 文件，这是 <code>TypeScript</code> 项目的配置文件，它包含了编译器的配置选项，我们暂时先不动它</p><p>在当前文件夹下新建 <code>index.ts</code> 文件，并编写：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;TypeScript&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;str&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure><p>之后在命令行输入 <code>tsc index.ts</code>，即可编译 <code>index.ts</code> ，同时编译生成的<code>index.js</code> 会被放在同一目录下</p><p>在命令行输入 <code>node index.js</code> ，如果成功输出了 <code>Hello, TypeScript!</code>，证明你的电脑已经成功安装 TypeScript 编译器</p><h2 id="TypeScript-的变量类型"><a href="#TypeScript-的变量类型" class="headerlink" title="TypeScript 的变量类型"></a>TypeScript 的变量类型</h2><p>TypeScript 的变量类型与C语言相比简单的多，仅有<strong>布尔类型( <em>boolean</em> )</strong>、<strong>数字类型( <em>number</em> )</strong>、<strong>字符串类型( <em>string</em> )</strong>、<strong>未定义类型( <em>undefined</em> )</strong>、<strong>空类型( <em>null</em> )</strong>、<strong>大数类型( <em>bigint</em> )</strong>、<strong>符号类型( <em>symbol</em> )</strong>、<strong>任意类型( <em>any</em> )</strong>、<strong>never类型( <em>never</em> )</strong></p><p>其中有必要细讲的是未定义与空，还有任意类型。大数和符号不常用，感兴趣可以自行Google</p><h4 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h4><p>未定义和空都表示空，但 <code>null</code> 表示这个元素存在，但是是空的； <code>undefined</code> 表示这个元素干脆就不存在。且 <code>undefined</code> 要比 <code>null</code> 常见的多</p><p>这两个类型的相同点是，他们都是只有一个值的数据类型， <code>undefined</code> 的值只有 <code>undefined</code> ， <code>null</code> 的值只有 <code>null</code></p><p>我们先看一张比较经典的图片，该图来自 stackoverflow 的回答</p><p><img src="/2024/01/21/17-16-23/T9M2J.png" alt="T9M2J"></p><ul><li>非零值就像一个装有卫生纸卷的支架，并且管子上仍然有纸巾。</li><li>零值就像一个带有空卫生纸管的支架。</li><li>空值就像一个没有卫生纸管的支架。</li><li>未定义就像连支架都没有</li></ul><p>对于一个未定义的变量，执行 <code>typeof</code> 操作符，那么就会返回 <code>undefined</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(data)); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(src)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里我们没有使用 <code>===</code> 来判断，因为对于尚未声明过的变量，我们只能执行使用typeof操作符检测其数据类型这个操作，使用其他的操作都会报错</p><p>还有使用对象中不存在的属性，也会返回 <code>undefined</code> ：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line"><span class="attr">prop</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">abcdefg</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>从逻辑角度来看， <code>null</code> 值表示一个空对象指针，指示变量未指向任何对象，常在返回类型是对象，但没关联值的地方使用，就像下面：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>); <span class="comment">// container是不存在的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($container); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>如果一个变量已经定义，并且它的值为 <code>null</code> ，那么他的类型就是：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(data)); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>你会发现他的类型并不是 <code>null</code>， 而是一个对象。这并不奇怪。从逻辑角度来看， <code>null</code> 值表示一个空对象指针，它代表的其实就是一个空对象。</p><h4 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h4><p>当你不知道该标记什么类型，或者你希望可以写任何类型时，可以谨慎使用 <code>any</code>，编译器将不会尝试对 <code>any</code> 类型的变量做任何的分析。</p><p> <code>any</code>  类型是目前 TypeScript 语言之中具有较大争议的一个设计，因为理论上我们可以将所有的变量声明为 <code>any</code> 从而绕过类型检查，这个时候 TypeScript 实际上退化为 JavaScript</p><p>但是考虑到目前 Web 前端项目会引用大量的第三方库，开发者很多时候无法完全把握某些变量的信息，所以 <code>any</code> 类型是必要的。不过我们需要注意其使用，对于能够给定类型的变量则尽量不标记为  <code>any</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">any</span> = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">num = <span class="number">2333</span>; <span class="comment">// OK</span></span><br><span class="line">num = <span class="literal">true</span>; <span class="comment">// OK</span></span><br><span class="line">num = <span class="literal">undefined</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h4 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h4><p>TypeScript 支持一种特殊的类型，即 <code>never</code> 类型。这种类型常被用于标注函数返回值，代表这个函数永远不会终结或者会抛出异常：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> neverEnd = (): <span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种类型的值永远不能被实例化，也即尝试声明和使用 <code>never</code> 类型的值将会总是出现错误，利用个特点，我们可以检测程序是否考虑了所有的情况，这被称为耗尽检查：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">All</span> = <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="comment">// switch 语句用法与 C/C++ 一致</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">value: All</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">typeof</span> value) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">let</span> <span class="attr">exhaustiveCheck</span>: <span class="built_in">never</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>never</code> 的特点，<code>default</code> 分支的代码执行必然会产生错误，因此如果该 <code>switch</code> 语句未能穷尽 <code>typeof value</code> 的可能取值，使得代码落入 <code>default</code> 分支，导致 <code>never</code> 类型的变量被实例化，进而导致编译器报错</p><p>如果修改类型 <code>All</code> 为 <code>number | string | boolean | undefined</code>，编译器会告诉我们<em>不能将类型“undefined”分配给类型“never”</em>，这就是因为当 <code>value === undefined</code> 时，会尝试将 <code>undefined</code> 赋给 <code>never</code> 类型的变量。 这样，<code>handler</code> 函数就会因为没有耗尽所有可能而报错</p><h2 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h2><p>声明变量时可以在变量后面标注类型，也可以根据初始值自动推断，但如果声明变量时不赋初始值，则必须添加类型标注，否则在使用时会报错（即自动推断该变量为 <code>undefined</code> 的类型，因此不能赋其他值）。</p><h4 id="普通类型标注"><a href="#普通类型标注" class="headerlink" title="普通类型标注"></a>普通类型标注</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Count</span>: <span class="built_in">number</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, TypeScript!&quot;</span>;</span><br></pre></td></tr></table></figure><p>也就是在变量名字后面紧接着跟一个冒号，再加上类型就可以了</p><p>但需要注意的是 TypeScript 允许使用字面量作为类型标注，如：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">one</span>: <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">one = <span class="number">2</span>;   <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>这里变量 <code>one</code> 的类型被限定为字面量 <code>1</code> 而不是所有的 <code>number</code>，这种标注的作用在下面会展示。</p><h4 id="对象和数组的标注"><a href="#对象和数组的标注" class="headerlink" title="对象和数组的标注"></a>对象和数组的标注</h4><p>对象：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="built_in">string</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;No. 2, Linggong Road, Ganjingzi District, Dalian City, Liaoning Province&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有元素均相同的数组：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;Embedded&#x27;</span>, <span class="string">&#x27;Web&#x27;</span>, <span class="string">&#x27;Media&#x27;</span>];</span><br><span class="line"></span><br><span class="line">learning_direction = <span class="string">&#x27;Web&#x27;</span>; <span class="comment">// Error! 不能将类型“string”分配给类型“string[]”</span></span><br><span class="line">learning_direction = [<span class="string">&#x27;Web&#x27;</span>]; <span class="comment">// Success</span></span><br></pre></td></tr></table></figure><p>固定长度和类型的数组：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: [<span class="built_in">number</span>, <span class="built_in">boolean</span>] = [<span class="number">1</span>, <span class="literal">false</span>];</span><br></pre></td></tr></table></figure><h4 id="函数的标注"><a href="#函数的标注" class="headerlink" title="函数的标注"></a>函数的标注</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，函数名为 <code>sum</code>， 两个参数类型均为 <code>number</code> ，返回值也为 <code>number</code></p><p>这里要注意的是，编译器会尝试推断函数返回值，但<strong>不会尝试从函数实现中</strong>推断参数类型，因此参数列表的类型标注是必不可少的。</p><p>也可以按照声明变量的方式：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>sum</code> 作为一个变量，它的类型并非前文所提过的原始值，因此也是一个对象，它的构造函数是 <code>function</code></p><p>如果使用箭头函数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法的结果相同</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt; x + y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然我们函数参数有了类型的限制，但是实际上 TypeScript 在运行时并不会检查你的调用是否符合参数列表（尽管在编译器会尝试进行静态检查，但是如果你使用 <code>any</code> 或其他一些方法传入其他类型参数，仍然会继续运行）</p><p>在 JavaScript 中，甚至不会检查你函数调用的时候传入参数的个数，但是 TypeScript 会阻止传入个数错误的参数</p><p>在 TypeScript 中可以通过将参数标为可选或提供默认值来允许不同长度的传入参数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">1</span>, z?: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123; <span class="comment">// y的默认值是1，z为可选参数</span></span><br><span class="line">    <span class="keyword">return</span> x + y + (z ?? <span class="number">0</span>);  <span class="comment">// 这里 y 不可能为空值，但 z 可能。如果函数调用没有给出z，那么z默认是0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>));        <span class="comment">// =&gt; 1 + 1 + (undefined ?? 0) = 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">0</span>));     <span class="comment">// =&gt; 1 + 0 + (undefined ?? 0) = 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// =&gt; 1 + 2 + (3 ?? 0) = 6</span></span><br></pre></td></tr></table></figure><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>可以使用 <code>type</code> 关键词定义类型别名，在需要实现复杂的类型时非常有用：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> numberOne = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">one</span>: numberOne = <span class="number">1</span>;</span><br><span class="line">one = <span class="number">2</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><h4 id="联合类型和类型收窄"><a href="#联合类型和类型收窄" class="headerlink" title="联合类型和类型收窄"></a>联合类型和类型收窄</h4><p> TypeScript 可以将变量的类型声明为若干个类型之一，这称为联合类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">union</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">7</span>;</span><br><span class="line">union = <span class="string">&quot;Genshin Impact&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">union = <span class="number">8</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>上面的 <code>union</code> 变量，既可以是 <code>number</code> 类型，也可以是 <code>string</code> 类型</p><p>联合类型最常用的地方是标注函数参数，这样就允许了函数接受多种类型的参数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addHello = (<span class="attr">x</span>:<span class="built_in">number</span> | <span class="built_in">string</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span> + x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addHello</span>(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">addHello</span>(<span class="string">&quot;Dalian&quot;</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>上文提到字面量可以作为类型标注，那么使用联合类型，就可以实现枚举行为：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> oddNumber = <span class="number">1</span> | <span class="number">3</span> | <span class="number">5</span> | <span class="number">7</span> | <span class="number">9</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: oddNumber = <span class="number">5</span>; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: oddNumber = <span class="number">2</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p><em>这就是上面提到的复杂类型之一</em></p><p>对于“所有元素均相同的数组”的实例代码出现的错误，如果更改为下面的代码：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] = [<span class="string">&#x27;Embedded&#x27;</span>, <span class="string">&#x27;Web&#x27;</span>, <span class="string">&#x27;Media&#x27;</span>];</span><br><span class="line"></span><br><span class="line">learning_direction = <span class="string">&#x27;Web&#x27;</span>; <span class="comment">// Success</span></span><br><span class="line">learning_direction = [<span class="string">&#x27;Web&#x27;</span>]; <span class="comment">// Success</span></span><br></pre></td></tr></table></figure><p>这里我们声明 <code>learning_direction</code> 可能有两种类型，即 <code>string</code> 和 <code>string[]</code>，所以我们可以将其任意赋值为其中的一种，但这就导致我们在使用这一值时，不能精确判断上面包含的方法，例如我们尝试执行：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learning_direction.<span class="title function_">match</span>(<span class="regexp">/react/</span>); <span class="comment">// Error! 类型“string[]”上不存在属性“match”</span></span><br></pre></td></tr></table></figure><p>这里编译器会报错，但如果我们的代码足以让编译器推断出来变量类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> learning_direction === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(learning_direcion.<span class="title function_">match</span>(<span class="regexp">/react/</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够进入 <code>if</code> 判断的第一个大括号的语句，那 <code>learning_direction</code> 就一定是 <code>string</code> 类型，编译器自己就能够明白，这么做是安全的，允许调用相应的方法，这种行为被称为<strong>类型收窄</strong></p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>这种语法只用在一种情况：你认为你比编译器还懂这个变量的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">learning_direction</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] = [<span class="string">&#x27;Embedded&#x27;</span>, <span class="string">&#x27;Web&#x27;</span>, <span class="string">&#x27;Media&#x27;</span>];</span><br><span class="line"></span><br><span class="line">(learning_direction <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">match</span>  (<span class="regexp">/react/</span>);</span><br></pre></td></tr></table></figure><p>我们这里使用 <code>as</code> 关键字，告诉编译器 <code>learning_direction</code> 这个变量一定为 <code>string</code> 类型，不可能是 <code>string[]</code> 类型，这个时候编译器就会听你的，把他它当作  <code>string</code> 类型处理</p><p>但你不能断言一个变量为明显冲突的类型</p><p>比如上述代码，如果是 <code>(learning_direction as string).match  (/react/);</code> ，那么就会报错，所以我们要先断言为 <code>unknown</code> 再断言为其他类型</p><h2 id="TypeScript-的复杂类型"><a href="#TypeScript-的复杂类型" class="headerlink" title="TypeScript 的复杂类型"></a>TypeScript 的复杂类型</h2><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>这类似于C++的模板</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数泛型</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是函数泛型</span></span><br><span class="line"><span class="keyword">const</span> identity = &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="function"><span class="params">Type</span> =&gt;</span> arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;<span class="title class_">NumType</span>&gt; &#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: <span class="title class_">NumType</span>;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象泛型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Request</span>&lt;<span class="title class_">ReqBody</span>, <span class="title class_">ResBody</span>&gt; &#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="title class_">ReqBody</span>;</span><br><span class="line">    <span class="attr">response</span>: <span class="title class_">ResBody</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//别名泛型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MaybeArray</span>&lt;<span class="title class_">Value</span>&gt; = <span class="title class_">Value</span> | <span class="title class_">Value</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">//它们的实例化</span></span><br><span class="line">identity&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">req</span>: <span class="title class_">Request</span>&lt;&#123; <span class="attr">action</span>: <span class="built_in">string</span> &#125;, &#123; <span class="attr">result</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">    <span class="attr">request</span>: &#123;</span><br><span class="line">        <span class="attr">action</span>: <span class="string">&#x27;update system&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">response</span>: &#123;</span><br><span class="line">        <span class="attr">result</span>: <span class="string">&#x27;succeeded&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">nums</span>: <span class="title class_">MaybeArray</span>&lt;<span class="built_in">number</span>&gt; = <span class="number">0</span>;</span><br><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>可以为泛型添加限制和默认值，也可以由编译器推断泛型类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span> = <span class="built_in">number</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identity</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">data</span>: <span class="built_in">string</span> &#125;&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identity</span>(&#123; <span class="attr">data</span>: <span class="string">&quot;str&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="typeof-和-keyof-关键字"><a href="#typeof-和-keyof-关键字" class="headerlink" title="typeof 和 keyof 关键字"></a>typeof 和 keyof 关键字</h4><p><code>typeof</code> 除了可以作为运算符获取变量类型以外，用作类型标注时，可以获取变量的具体类型（而非作为运算符时的有限种类）：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someObj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg: <span class="keyword">typeof</span> someObj</span>) &#123; <span class="comment">// arg: &#123; foo: number; bar: string &#125;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>keyof</code> 可以获取类型的键的类型：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg: keyof <span class="keyword">typeof</span> Obj</span>) &#123; <span class="comment">// arg: &#x27;foo&#x27; | &#x27;bar&#x27;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>与C语言的三目运算符语法相同，但是在 TypeScript 中与泛型结合会更有用</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">any</span> &#125; ? T[<span class="string">&#x27;message&#x27;</span>] : <span class="built_in">unknown</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;;  <span class="comment">// EmailMessageContents = string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Dog</span>&gt;;      <span class="comment">// DogMessageContents = unknown</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是TypeScript？&quot;&gt;&lt;a href=&quot;#什么是TypeScript？&quot; class=&quot;headerlink&quot; title=&quot;什么是TypeScript？&quot;&gt;&lt;/a&gt;什么是TypeScript？&lt;/h2&gt;&lt;p&gt;简而言之，TypeScript 是 Java</summary>
      
    
    
    
    <category term="前端开发" scheme="https://houyi2333.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>1_什么是线性、什么是线性代数</title>
    <link href="https://houyi2333.github.io/2024/01/09/14-54-42/"/>
    <id>https://houyi2333.github.io/2024/01/09/14-54-42/</id>
    <published>2024-01-09T06:54:42.000Z</published>
    <updated>2024-01-22T03:34:24.872Z</updated>
    
    <content type="html"><![CDATA[<p>线性代数作为大学里最重要的数学基础课之一，是大批学生的噩梦。相较而言，高数虽然内容繁杂，各种奇技淫巧频频出现，但由于高中课程中对导数等概念和相应工具的启蒙，且涉及微积分基本思想的数学故事也不少，加上近年来不少民科对微积分的攻击也帮助了一些简单微积分知识的普及，因而理工科的高数类课程反而不会让人觉得难以理解。</p><p>线性代数则不然，它往往让不少人从翻开书的第一页起一直懵逼到期末，讲的都是些什么玩意儿？ 最后迫不得已，一夜刷尽往年卷，匆匆应对期末考，从此相见不相识。</p><p>总的来说，教材的大致思路是先以某种方式定义矩阵，然后引入行列式，立马就开始计算。先对矩阵各种算——左乘右乘左右乘、求逆求秩求幂方，接着就开始了迷之特征值和向量空间，还有相似对角和相合，画风相当凌乱，根本不知道线性代数到底是什么，反正就是求和算。</p><p>这门课我也上完一年多了，最近也用到了很多线代中的知识，越发体会到这门课的重要性，于是准备把他重新捡起来，一边学一边讲解自己对线代的理解。</p><hr><p><strong><em>以下是正文：</em></strong></p><p>这是《线性代数》这一章的第一篇文档，本篇不会讲线代的具体内容，仅会对线性代数进行一个介绍</p><p>什么是线性？我们考虑这样一个初中问题</p><script type="math/tex; mode=display">求方程组\left\{ \begin{array}{l}    2x-y=0\\    -x+2y=3\\\end{array} \right.的解</script><p>我们先抛开代数消元不谈，从几何上我们可以这么理解这个问题</p><script type="math/tex; mode=display">求直线2x-y=0和直线-x+2y=3的交点的坐标</script><p><img src="/2024/01/09/14-54-42/image-20240109150913411.png" alt="image-20240109150913411"></p><p>显然交点的坐标为$(1,2)$，所以方程组的解为$x=1, y=2$</p><p>那么我们还知道，这个方程组叫做线性方程组，为什么呢？因为这个方程组的所有方程都是线性方程。什么是线性方程呢？我们把形如$a_1x_1+a_2x_2+\cdots+a_nx_n=b$的方程叫做线性方程，因为他表示了n维空间内的一个……，我也不知道，我只知道二元一次方程就表示了二维平面内的一条直线，三元一次方程就表示了三维空间内的一个平面。反正我无法想象三维以上的空间。</p><p>线性方程组是由一个或多个包含相同变量的未知数的线性方程组成的，其一般形式为：</p><script type="math/tex; mode=display">\left\{ \begin{array}{l}    a_{11}x_1+a_{12}x_2+\cdots +a_{1n}x_n=b_1\\    a_{21}x_1+a_{22}x_2+\cdots +a_{2n}x_n=b_2\\    \vdots\\    a_{m1}x_1+a_{m2}x_2+\cdots +a_{mn}x_n=b_m\\\end{array} \right.</script><p>这是m个n元一次方程，表示了n维空间内的一个……，嗯，就是那个……</p><p>现在我们再回到上面那个初中问题，如果把这个方程组竖着看会怎么样</p><script type="math/tex; mode=display">已知\vec{a}=\left( 2,-1 \right) ，\vec{b}=\left( -1,2 \right) ，\vec{c}=\left( 0,3 \right)，求实数x、y，使得x\vec{a}+y\vec{b}=\vec{c}</script><p>它变成了一个平面二维向量的组合问题，对$\vec{a}$和$\vec{b}$进行一个线性组合，使其能够得到$\vec{c}$。什么是线性组合？它的定义是这样的</p><script type="math/tex; mode=display">对于若干个n维向量：\vec{a_1}, \vec{a_2}, \cdots, \vec{a_m}\\对每个向量都乘上一个系数后相加：k_1\vec{a_1}+k_2\vec{a_2}+\cdots+\vec{a_m}k_m=\vec{b}\\我们称\vec{b}是这若干个n维向量的一个线性组合，也叫做线性表示</script><p>对于上面的初中问题，让x取1，y取2就可以成功组合出来$(0, 3)$这个向量</p><p>现在我们思考另一个问题，所有的线性组合是什么？这种问题在这门课中会频繁出现。选取所有的x和y，所有的组合，结果是你会得到任意的二维向量，也就是对这两个向量进行不同的线性组合可以得到所有平面向量，这是我们高中学过的平面向量基本定理。这种线性组合的思想，是线性代数这门课的基础</p><p>接下来我们考虑三个方程三个未知数的方程组</p><script type="math/tex; mode=display">求方程组\left\{ \begin{array}{l}    2x-y=0\\    -x+2y-z=-1\\    -3y+4z=4\\\end{array} \right.的解</script><p>我们先把这个方程横着看，这是三维空间中的三个平面相交，求交点的坐标</p><p>如果把这个方程竖着看，那就是三维空间的三个向量的线性组合，使其能够组合出来等号右边的向量</p><p>现在我们思考另一个问题，所有的线性组合是什么？这是我们高中学过的空间向量基本定理，对于三个不共面的三维向量，其线性组合可以覆盖到整个三维空间。如果有两个向量位于同一个平面，那这两个向量中的一个将对向量组毫无贡献，这样的线性组合就只能覆盖到一个二维平面</p><p>那大家是否能想象出来四维空间中4个向量的组合，n维空间中n个向量的组合？显然，我们想象不出来。但在学完线性代数这门课以后，我们就会意识到，这n个向量有机会覆盖到整个n维空间。这很难直观的想象出来，我们也可以说这是某种平面。如果这n个向量中有两个向量是“共面”的，那么这n个向量就只能覆盖到n维空间中的某n-1维平面，最后的求解也只能在这n-1维平面上展开</p><p>线性代数是数学的一个分支，它的研究对象是向量，向量空间（或称线性空间），线性变换和有限维的线性方程组。这些概念和方法在数学、物理学、工程学、计算机等领域中都有广泛的应用。例如，在数学中，线性代数被广泛地应用于抽象代数和泛函分析中；在计算机领域中，线性代数被广泛地应用于计算机图形学、密码学、计算机视觉等方面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线性代数作为大学里最重要的数学基础课之一，是大批学生的噩梦。相较而言，高数虽然内容繁杂，各种奇技淫巧频频出现，但由于高中课程中对导数等概念和相应工具的启蒙，且涉及微积分基本思想的数学故事也不少，加上近年来不少民科对微积分的攻击也帮助了一些简单微积分知识的普及，因而理工科的高</summary>
      
    
    
    
    <category term="线性代数" scheme="https://houyi2333.github.io/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>唉，计组</title>
    <link href="https://houyi2333.github.io/2024/01/07/17-04-19/"/>
    <id>https://houyi2333.github.io/2024/01/07/17-04-19/</id>
    <published>2024-01-07T09:04:19.000Z</published>
    <updated>2024-01-22T03:33:08.754Z</updated>
    
    <content type="html"><![CDATA[<p>今天是个特殊的日子：赖晓晨的计组出分了</p><p>好消息是分数还不错，在期末考试几乎没有会的题的情况下竟然拿到了80分，这说明赖晓晨在中等成绩段上给分还是不错的</p><p>听说去年最高分也只有88分，可能确实是在他手上很难拿高分吧</p><hr><p><strong><em>以下是正文：</em></strong></p><p>首先恭喜同学成功的选上了赖晓晨老师的计算机组织与结构这门课</p><p>赖晓晨非常喜欢华为这个企业，上课会穿插极其多的华为的内容，期末考试也会涉及一些华为的内容，尤其是华为的鲲鹏处理器</p><p>赖晓晨老师上课的流程是，先扫码进雨课堂，课中会时不时在雨课堂发送测试题，并且每道题只有 30-60s 的时间来作答，如果翘课是很难通过别人提醒来及时作答的。同时，课上还会提问坐在后排的学生，如果没答上来，还会要求该学生坐到第一排。后来你会发现，教室里只有前5排有学生，后面一个都没有。同时，上课抢答的同学会记名，加平时分。同时，还会有翻转课堂，也就是学生讲课，自愿报名，报名的加平时分。同时，成绩构成也很复杂，各种形式五花八门，给大家看一下成绩构成</p><p><img src="/2024/01/07/17-04-19/image-20240107170838300.png" alt="image-20240107170838300"></p><p>课后作业包括两部分，一部分是课本课后习题，会挑一些做，这个没什么问题，量也不多，与其他老师都一样。但是其他老师的平时成绩也就是这些课后习题了，而赖晓晨老师为了让学生全面发展，课后作业又新增了一项——代码作业</p><p>代码作业我这一届是有5个，如下图：</p><p><img src="/2024/01/07/17-04-19/image-20240107170921333.png" alt="image-20240107170921333"></p><p>这个代码作业是线上提交C语言代码，但是这个代码的难度。。。反正我写不出来，并且ChatGPT也写不出来。作业的1003，我的代码通过了课本所有的例题，但是就是通不过他给的样例，最后喜提75分</p><p>同时，这个作业的代码会进行查重，如果你跟另一个同学的代码相似度过高，两个人本次作业会被直接判为0分。</p><p>同时，赖晓晨老师还设置了课内实验和微认证这两个部分</p><p>课内实验是什么呢，是赖晓晨老师亲手写的<strong>122页</strong>PDF，这个PDF教给了你如何租用华为鲲鹏920服务器，如何使用open Euler操作系统，如何编写ARMV8汇编程序，如何对汇编代码进行优化等等内容，并且还有每一个实验都紧跟着一个思考题，每一个实验不做思考题大概耗时1.5h。但是如果考虑到用电脑时诸如水群和看视频等其他操作，可能需要一晚上甚至更多时间才能做完一个实验。总共有5个实验需要做。</p><p>这个实验对于没有服务器租用经验和Linux系统使用经验的同学来说，我个人认为还是有挑战性的，open Euler是一个没有GUI的操作系统，仅能使用shell命令和vim编辑器进行操作</p><p>接下来讲微认证的5分</p><p>这个微认证的内容是华为鲲鹏处理器知识，有很多的课可以选，只要完成必做的一个+任选一个，共完成两个，就可以拿到这五分</p><p><img src="/2024/01/07/17-04-19/image-20240107171104951.png" alt="image-20240107171104951"></p><p>其中必做的是“揭秘鲲鹏处理器”，剩下一个建议选择“鲲鹏软件迁移实践”，因为这个在CSDN上有题库可以抄）</p><p>这个题目难度，我就呃呃了，真的很难考，给大家看看我的分数，70分及以上算通过本次考试</p><p><img src="/2024/01/07/17-04-19/image-20240107171643108.png" alt="image-20240107171643108">                     <img src="/2024/01/07/17-04-19/image-20240107171650661.png" alt="image-20240107171650661"></p><p>这个微认证，每个课都是需要花费一张代金券的，代金券一个周能且仅能领一张，且限量500张，如果被抢没了，那这个周你想做也做不了了</p><p>当然，上述还没有考虑到大作业，当然大作业是选做的，也不知道做大作业是更容易及格还是更不容易及格</p><p>大作业的要求是，根据那<strong>122页</strong>PDF给出的实验，自己创新性的提出新的实验，实验内容要求与鲲鹏处理器技术的内容高度相关，实验文档的结构也要与实验手册一致，包括实验目的、实验设备、实验原理、实验任务操作指导以及思考题。由于我们并没有深入学习过鲲鹏920处理器，也不了解ARMV8架构和Linux操作系统，也不了解处理器内部结构，个人认为想要设计这个实验还是很难的，虽然我当年选择了做大作业，自己设计了一个实验）</p><p>大作业也不像其他老师一样交上去就完事了，需要三个人一起组队完成，要开题答辩，最终答辩，开题答辩还需要刷人，最终答辩如果不理想也要被刷掉。被刷掉了成绩构成就要回归第一种方案，也就是没有大作业，所以即使做了大作业，赖晓晨老师也不一定会让允许你的大作业计入期末成绩，可能会前功尽弃。</p><p>本人对赖晓晨老师的评价是，讲课极其认真，如果认真完成每一个作业，真的可以学到很多在其他老师课堂上学不到的东西，但是从成绩的角度讲，确实不容易拿到很高的分数。并且选他的课事情会极其极其极其的多，想摆烂求及格的同学千万不要选，会忙的你痛不欲生</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是个特殊的日子：赖晓晨的计组出分了&lt;/p&gt;
&lt;p&gt;好消息是分数还不错，在期末考试几乎没有会的题的情况下竟然拿到了80分，这说明赖晓晨在中等成绩段上给分还是不错的&lt;/p&gt;
&lt;p&gt;听说去年最高分也只有88分，可能确实是在他手上很难拿高分吧&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;stro</summary>
      
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>具体数学笔记</title>
    <link href="https://houyi2333.github.io/2024/01/04/18-38-27/"/>
    <id>https://houyi2333.github.io/2024/01/04/18-38-27/</id>
    <published>2024-01-04T10:38:27.000Z</published>
    <updated>2024-01-22T03:36:27.907Z</updated>
    
    <content type="html"><![CDATA[<p>这门课在大工只有软院开，并且极其的抽象，虽然他叫具体数学</p><p>这门课的虽然很抽象，但是考试很简单，全部源自 PPT 和作业题，几乎连数都不变</p><p>这里在知识点上进行了一下总结（其实就是把 PPT 用人话说了一遍），建议先看会知识点，再看 PPT 的题，再看作业题</p><p>下载链接：<a href="具体数学/具体数学笔记.pdf" download>具体数学笔记</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这门课在大工只有软院开，并且极其的抽象，虽然他叫具体数学&lt;/p&gt;
&lt;p&gt;这门课的虽然很抽象，但是考试很简单，全部源自 PPT 和作业题，几乎连数都不变&lt;/p&gt;
&lt;p&gt;这里在知识点上进行了一下总结（其实就是把 PPT 用人话说了一遍），建议先看会知识点，再看 PPT 的题，再</summary>
      
    
    
    
    <category term="具体数学" scheme="https://houyi2333.github.io/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>VSCode自动格式化.c and .cpp文件并开启自动保存</title>
    <link href="https://houyi2333.github.io/2023/10/06/13-11-21/"/>
    <id>https://houyi2333.github.io/2023/10/06/13-11-21/</id>
    <published>2023-10-06T05:11:21.000Z</published>
    <updated>2024-01-22T03:30:23.937Z</updated>
    
    <content type="html"><![CDATA[<p>打开 VSCode 的设置，搜索 Format ，将搜索到的选项设置成如下格式，这样就打开了自动格式化</p><p><img src="/2023/10/06/13-11-21/3cfc97729ba949edbac614d0d90e00b1.png" alt="3cfc97729ba949edbac614d0d90e00b1"><br>在设置中搜索 Auto Save ，将 <code>Files: Auto Save</code> 改为 <code>onFocusChange</code>，这样就开启了自动保存</p><p><img src="/2023/10/06/13-11-21/36e4dcbc98ac4282a2359ca9da791d36.png" alt="36e4dcbc98ac4282a2359ca9da791d36"><br>还有一个让强迫症患者很头大的问题：大括号是换行还是不换行？</p><p><img src="/2023/10/06/13-11-21/00224dc01a8e4a72a668a8e10456ec2c.png" alt="00224dc01a8e4a72a668a8e10456ec2c"><br>在设置中搜索 C_Cpp.Clang_format_style ，填入 <code>&#123;BasedOnStyle: Chromium, IndentWidth: 4&#125;</code> </p><p><img src="/2023/10/06/13-11-21/f57336ae3841440183321d629da7b7d9.png" alt="f57336ae3841440183321d629da7b7d9"><br>这样大括号就会自动换行</p><p><img src="/2023/10/06/13-11-21/899708edb6dd4be0b39371828a9f8ec2.png" alt="899708edb6dd4be0b39371828a9f8ec2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;打开 VSCode 的设置，搜索 Format ，将搜索到的选项设置成如下格式，这样就打开了自动格式化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/10/06/13-11-21/3cfc97729ba949edbac614d0d90e00b1.png&quot; alt=&quot;3cfc</summary>
      
    
    
    
    <category term="VSCode" scheme="https://houyi2333.github.io/categories/VSCode/"/>
    
    
  </entry>
  
  <entry>
    <title>大连理工大学软件学院新生学习指南</title>
    <link href="https://houyi2333.github.io/2023/09/22/20-57-01/"/>
    <id>https://houyi2333.github.io/2023/09/22/20-57-01/</id>
    <published>2023-09-22T12:57:01.000Z</published>
    <updated>2024-01-22T02:24:42.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大连理工大学软件学院新生学习指南"><a href="#大连理工大学软件学院新生学习指南" class="headerlink" title="大连理工大学软件学院新生学习指南"></a>大连理工大学软件学院新生学习指南</h1><h3 id="大一上学期课程简介以及成绩计算相关"><a href="#大一上学期课程简介以及成绩计算相关" class="headerlink" title="大一上学期课程简介以及成绩计算相关"></a>大一上学期课程简介以及成绩计算相关</h3><p>软件学院大一上学期的课程有：大学生心理健康教育（<strong>2 学分</strong>）、大学英语 1（<strong>2 学分</strong>）、健康教育（<strong>0.5 学分</strong>）、计算机系统实践（<strong>1 学分</strong>）、体育-基础 1（<strong>0.5 学分</strong>）、信息技术导论（<strong>1 学分</strong>）、思想道德与法治（<strong>2.5 学分</strong>）、程序设计基础与 C 语言程序设计（<strong>4 学分</strong>）、工科数学分析基础 1（<strong>5 学分</strong>）、军训（<strong>2 学分</strong>）</p><p>（大学的课程都有简称，以上课程简称依次为：心理健康，大英 1，健康教育，计算机系统实践、体育、导论课、思修，思政、C 语言、工数 1，高数 1，微积分 1，军训）</p><p>其中计入保研的有：大英 1、计算机系统实践、导论、思政、C 语言、工数 1、军训</p><p>大学的排名是根据均分排的，均分由平均成绩、单项奖学金、竞赛、论文等组成，平均成绩的计算公式是：</p><script type="math/tex; mode=display">\text{假设课程}n\text{的分数为}M_n\text{，学分为}N_n\text{那么你的平均成绩为}\frac{\sum_{i=1}^n{M_i\times N_i}}{\sum_{j=1}^n{N_j}}</script><p><code>注：以下评分标准与授课内容仅适用于22级，其他年级若有出入属于正常情况</code></p><h3 id="这些课是学什么的，以及容不容易挂科"><a href="#这些课是学什么的，以及容不容易挂科" class="headerlink" title="这些课是学什么的，以及容不容易挂科"></a>这些课是学什么的，以及容不容易挂科</h3><p>心理健康就是字面意思，会讲大学生如何才能保持一个正常的心理状态，有不正常的心理状态会怎么样。目前没有正常人挂过科</p><p>大英 1 会发一本巨厚的书，老师会讲里面的课文，讲里面的单词和句子，还有阅读理解。目前没有正常人挂过科</p><p>健康教育会讲常见疾病，得病了后如何自我诊断，如何正确就医。虽然课程简单，但是普遍低分且有部分人挂科</p><p>计算机系统实践教装机、装系统，上课跟着实操，下课后交报告。目前没有正常人挂过科</p><p>体育学什么要看你选的什么课，由于我不可能上过所有体育课，无法下结论是否容易挂科</p><p>信息技术导论，每节课都会请一个巨佬来作报告，讲前沿知识，然后课下写论文交作业。目前没有正常人挂过科</p><p>思想道德与法治，类似于高中政治课，凭借朴素的爱国情怀就可以及格，你要是挂科了建议出门左转去大连市公安局经济技术开发区分局自首</p><p>C 语言，字面意思就学 C 语言，有挂科的，但是不多，不容易挂（注意，软件学院 C 语言不是在电脑上考试，是纸质试卷手写代码，禁止使用电子设备）</p><p>工数 1，跟高等数学学的几乎一样，是大一<strong>最容易</strong>挂科的课</p><p>军训：不清楚，写这个文档的时候我正在军训</p><h3 id="计入保研的课怎么学-怎么考试"><a href="#计入保研的课怎么学-怎么考试" class="headerlink" title="计入保研的课怎么学/怎么考试"></a>计入保研的课怎么学/怎么考试</h3><p>大英 1 平时会有测试，测试内容以及答案我都放在 NAOSI 的 GitHub 仓库了，为了高分可以提前把题直接背下来。期末考试前会有口语考试，形式是老师面前摆了 15 张卡片，一张卡片有一段话，这些段落都是平时学的课文里的。先把这段话读给老师听，然后老师会根据内容提问问题，问题可能是与课文内容相关的，要求对课文很熟悉，也有可能是开放性问题，比如我当时的问题就是平时会怎么做计划，考察口语能力。期末考试的形式是听力+阅读+单词，单词就是平时测试的，题目都给你们了背下来就行了，听力和阅读都是课外的，跟高中一样</p><p>计算机系统实践好好上课动手多操作一下，不要学计算机的对计算机一窍不通。不要像你们某学长一样，学计算机的不会装系统，不会加固态，甚至不会解压 rar。成绩是根据课下写的报告给的，建议里面图多一点，文字多水一点。（反正老师不管你怎么写的，你可以百度甚至跟历届学长要啊）</p><p>导论课好好水论文字数，好好调整好论文格式就行，给的分数相差不大</p><p>思政想要考高分还是要多背一背课本的，期末考的题全部是选择题，可以参考 NAOSI 仓库里的题库。不过本人思想觉悟不够高，思政学的并不好，不能给学弟提一些有效的建议</p><p>C 语言是软件工程课程的基础，这门课虽然教的极其老套，考试极其死板，但是如果学的不好，也很打击一个软件工程学生的自信心，会自身怀疑是否适合学软件工程这个专业。作为计算机专业的科班生，建议不要仅仅局限于课堂上老师教的内容，要以 C 语言为中心，自学其他内容。比如老师上课不会讲到的文件、算法设计，或者开发方面的。如果仅仅应付考试，多看老师发的 PPT，多看老师上课带着写的程序，学不会的去 b 站自己搜视频，或者查阅相关文档</p><p>工数 1 是从成绩上讲整个大一最最最最重要的课，与高中数学内容相关性比较高。工数 1 的成绩组成比较复杂，由作业+过程考核+MOOC 平台+期末考试组成，期末考试占 40%，平时占 60%。作业就是老师布置的作业，认真完成按时上交即可。过程考核一共有 3 次，时间听老师安排，一般是每一章讲完后的下周五，一次过程考核计入期末的 10 分，三次共 30 分，非常重要。过程考核内容为选择题+判断题，只考一章的内容，算是小型期中考试。并且过程考核的题目难度要大于期末考试，还会出一些比较恶心的卡概念的题，但考试的题目是从超级大的题库里抽的，题目难度与运气有关。过程考核的时间不是同一个时间，如果你是下午考的，可以利用自己的人际关系问一下上午都考了些什么，脸好的话会遇到原题。MOOC 平台就是线上完成作业，还有同学间互评打分，非常好得分，就是白送你的，但是总有人会忘记写 MOOC，或者写完了忘记互评，这些都会影响分数。期末考试由选择题和大题组成，比高中数学还老套，都是固定题型，想考高分平时就要刷题刷题还是刷题，刷考研题刷竞赛题，期末经常会从历年的考研或竞赛中拿几道改编一下。NAOSI 仓库里有个文件叫“每天起床头件事，先背一遍展开式”，是工数 1 和工数 2（这门课大一下要学）的复习提纲，有需要的自取</p><h3 id="后记（改编自-20-级某-m-姓学长）"><a href="#后记（改编自-20-级某-m-姓学长）" class="headerlink" title="后记（改编自 20 级某 m 姓学长）"></a>后记（改编自 20 级某 m 姓学长）</h3><p>无论成绩如何，一名软件工程专业的学生都应该在本科阶段掌握以下技能：</p><ul><li>自学</li><li>规范代码格式</li><li>熟练使用 IDE（ VSCode 严格来说不属于 IDE 但依然是宇宙第一）</li><li>阅读 API</li><li>阅读文档</li><li>数据结构与算法</li><li>英文读写</li><li>版本控制工具（Git）和开源仓库（GitHub/Gitee）的使用</li><li>撰写 LaTeX/Markdown 文档</li><li>答辩 （字面意思）</li></ul><h3 id="NAOSI-的-GitHub-仓库"><a href="#NAOSI-的-GitHub-仓库" class="headerlink" title="NAOSI 的 GitHub 仓库"></a>NAOSI 的 GitHub 仓库</h3><p>链接：<a href="https://github.com/NAOSI-DLUT/DLUT_SE_Courses">https://github.com/NAOSI-DLUT/DLUT_SE_Courses</a></p><p>这个仓库是干什么的呢，里面有：</p><ul><li><p>学长学姐亲传的资料</p></li><li><p>你寻找很久的电子参考书</p></li><li><p>前人细心雕琢出的大作业</p></li><li><p>历年真题</p></li><li><p>上完一门课才恍然领悟的技巧</p><p>2023.10.9 补充：<br>上午看见某学长在某个群里发表言论称，考前一个月突击一下，足够考门门 90 拿学习奖学金了，对于这个言论我的意见是，你们可以自己试试看，反正我做不到</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大连理工大学软件学院新生学习指南&quot;&gt;&lt;a href=&quot;#大连理工大学软件学院新生学习指南&quot; class=&quot;headerlink&quot; title=&quot;大连理工大学软件学院新生学习指南&quot;&gt;&lt;/a&gt;大连理工大学软件学院新生学习指南&lt;/h1&gt;&lt;h3 id=&quot;大一上学期课程简介</summary>
      
    
    
    
    <category term="学习指南" scheme="https://houyi2333.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>如何使用VSCode编译运行.c and .cpp文件</title>
    <link href="https://houyi2333.github.io/2023/09/21/23-05-53/"/>
    <id>https://houyi2333.github.io/2023/09/21/23-05-53/</id>
    <published>2023-09-21T15:05:53.000Z</published>
    <updated>2024-01-22T03:28:37.447Z</updated>
    
    <content type="html"><![CDATA[<p>首先先介绍一下 VSCode 是个什么东西</p><p>VSCode 是一款<strong>轻量级</strong>的<strong>代码编辑器</strong>，可以通过安装各种各样不同<strong>扩展</strong>的方式来实现开发者所需要的功能。</p><p>代码编辑器事实上我们可以看成是一个记事本（没错，就是你按下 Win+R 输入 notepad 回车之后的那个记事本），其最基本的功能是文档编辑。不过之所以将其称为是代码编辑器，是因为它虽然继承自一般的文档编辑器，又具备了一些一般的文档编辑器所不具备的功能。具体来说，例如自动语法高亮，自动补全，甚至是自动代码重构等等。<br>集成开发环境（IDE）是一种用于构建应用程序的软件，可将常用的开发人员工具合并到单个图形用户界面（GUI）中。具体来说，我们只需要简单的点击按钮，可能就可以完成程序的编译、链接、运行、调试等等工作。而这些工作在最初都是需要人手工在命令行中完成的。我们在《程序设计基础与C程序设计》课程中最初使用的 Dev-C++ 便是一个集成开发环境。<br>我们今天要介绍的 VSCode 是一款轻量级的代码编辑器。如果没有各种扩展插件的支持的话，可能我们只能把它称作是大号的记事本，而正是因为社区中各种各样的扩展，VSCode 才得以展现其强大。</p><h2 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h2><p>让我们打开 VSCode 官网：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p><p>点击红框里的 <code>Download for Windows</code>，之后浏览器就会自动下载</p><p><img src="/2023/09/21/23-05-53/1.png" alt="1"></p><p><img src="/2023/09/21/23-05-53/2.png" alt="2"></p><p><img src="/2023/09/21/23-05-53/3.png" alt="3">选择我同意此协议</p><p><img src="/2023/09/21/23-05-53/4.png" alt="4">五个复选框全部都打勾</p><p><img src="/2023/09/21/23-05-53/5.png" alt="5">点击安装</p><p>这样我们就能成功打开 VSCode</p><p><img src="/2023/09/21/23-05-53/6.png" alt="6"></p><h2 id="汉化VSCode"><a href="#汉化VSCode" class="headerlink" title="汉化VSCode"></a>汉化VSCode</h2><p>我们可以通过安装中文插件将其汉化</p><p><img src="/2023/09/21/23-05-53/7.png" alt="7"></p><p>重启后我们就得到了中文 VSCode</p><p><img src="/2023/09/21/23-05-53/8.png" alt="8"></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>我们可以先打开终端，尝试输入：<code>g++ --version</code></p><p>如果你的终端返回了  g++ 的版本信息，恭喜，您 C++ 编译器的环境变量配置正确，可以跳过这一章</p><p>如果你的终端返回了：<code>&#39;g++&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件。</code>那么则说明你的终端不知道 <code>g++</code> 是什么命令，接下来需要根据我的教程添加环境变量</p><p>什么是环境变量？</p><p>当你的 Shell 在执行命令时，会尝试在<strong>一系列路径</strong>下搜索同名的可执行文件。这一系列路径我们就称作是环境变量。</p><p>Windows 用户可以在终端中输入 path 来查看当前环境变量（由于我进行过一系列配置，所以其输出结果可能与你的不同）：</p><p><img src="/2023/09/21/23-05-53/image-20240119095335965.png" alt="image-20240119095335965"></p><p>没错，就是这一系列文件夹。回忆我们刚才执行 <code>g++ --version</code> 命令的时候，我们的终端会在这一系列文件夹下为我们寻找叫做 <code>g++</code> 的可执行文件。如果找到了名为 <code>g++</code> 的可执行文件，我们的终端就会将参数传入，将其执行；而如果我们的终端没有找到，那么就会向我们报告“未知命令”。</p><p>我们刚刚已经理解了环境变量的运行逻辑，接下来我们讲解如何进行环境变量的配置。</p><p>对于 Windows 用户，请按下 Windows + S 打开搜索框，在其中输入 <code>path</code>，然后选择”环境变量”，然后选择“系统变量”中的 Path 字段，双击打开后即可配置。</p><p>接下来我们安装MinGW64</p><p>MinGW 的全称是：Minimalist GNU on Windows。</p><p>它实际上是将经典的开源 C 语言编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux平台下的开发工具。</p><p>一句话来概括：MinGW 就是 GCC 的 Windows 版本。这是将你写的 C/C++ 语言的源代码编译成汇编代码，进而链接成可执行文件的工具。之前我们的 Dev-C++ 事实上也集成了这个工具。</p><p>我们下载官方的安装工具（<a href="[MinGW - Minimalist GNU for Windows download | SourceForge.net](https://sourceforge.net/projects/mingw/">链接</a>)），下载完成后打开，无需进行更改，一路点击下一步</p><p>安装完成之后会自动打开MinGW Installation Manager</p><p>我们点击左侧栏中的 Basic Setup ，右侧勾选 mingw32-base 和 mingw32-gcc-g++ 这两个包</p><p><img src="/2023/09/21/23-05-53/image-20240119101136811.png" alt="image-20240119101136811"></p><p>之后点击菜单栏中 Installation 的 Apply Changes</p><p><img src="/2023/09/21/23-05-53/image-20240119101243586.png" alt="image-20240119101243586"></p><p>等待片刻，MinGW即可安装在你的电脑中</p><p><img src="/2023/09/21/23-05-53/cb23ba556a7b40a59cd40145b2ac89d4.png" alt="cb23ba556a7b40a59cd40145b2ac89d4"></p><p>然后，我们需要进行环境变量配置。进入 <code>Mingw64 的安装路径/mingw64/bin/</code>，我们可以看到 <code>gcc</code>，<code>g++</code> 这些我们熟悉的可执行文件。<strong>然后我们需要做的就是将这个文件夹添加至环境变量中。</strong></p><p>然后我们就可以打开终端，输入 <code>g++ --version</code> 验证环境变量是否配置成功。（请注意，在环境变量配置后需要重启终端才能生效）</p><h2 id="插件安装与设置"><a href="#插件安装与设置" class="headerlink" title="插件安装与设置"></a>插件安装与设置</h2><p>这时候我们再装两个插件，一个叫 C/C++，一个叫 Code Runner</p><p><img src="/2023/09/21/23-05-53/6cd952d979ef4a7b994518d2c8c27c56.png" alt="6cd952d979ef4a7b994518d2c8c27c56">                                       <img src="/2023/09/21/23-05-53/2321a98cae5c4830b875837cf552685d.png" alt="2321a98cae5c4830b875837cf552685d"></p><p>然后我们在设置里搜索 code-runner.runInTerminal ，勾选这一项</p><p><img src="/2023/09/21/23-05-53/6f0c3688f1a349eca85d1118e620b2d0.png" alt="6f0c3688f1a349eca85d1118e620b2d0"></p><h2 id="VSCode，启动！"><a href="#VSCode，启动！" class="headerlink" title="VSCode，启动！"></a>VSCode，启动！</h2><p>之后我们点击这个按钮就能在内部终端运行.c 程序了</p><p><img src="/2023/09/21/23-05-53/ac14f764aa4a4bc2a087b9a90821bc9f.png" alt="ac14f764aa4a4bc2a087b9a90821bc9f"></p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>那如果你习惯了用外部终端，可以这样设置一下</p><p>在设置中搜索 code-runner.languageIdToFileExtensionMap ，并在 setting.json 中编辑文件</p><p>在”code-runner.executorMap”这个对象键中加入以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;code-runner.executorMap&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;cpp&quot;</span>: <span class="string">&quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;c&quot;</span>: <span class="string">&quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先先介绍一下 VSCode 是个什么东西&lt;/p&gt;
&lt;p&gt;VSCode 是一款&lt;strong&gt;轻量级&lt;/strong&gt;的&lt;strong&gt;代码编辑器&lt;/strong&gt;，可以通过安装各种各样不同&lt;strong&gt;扩展&lt;/strong&gt;的方式来实现开发者所需要的功能。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="VSCode" scheme="https://houyi2333.github.io/categories/VSCode/"/>
    
    
  </entry>
  
</feed>
